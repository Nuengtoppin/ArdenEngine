
---

# **1.0. Обзор / mini-README раздела Rotation**

Раздел **Rotation** описывает, как воксельно-топологическое пространство
(см. документы *Topology* и *Routing*) может **переориентироваться во вращении**,
не нарушая структуру и адресацию.

Rotation — это слой **дискретных поворотов** (0° / 90° / 180° / 270°) вокруг оси Y,
который задаёт единые правила для:

* поворота глобальных координат `XYZ` (world-space),
* поворота локальных координат уровней топологии
  *(Region-local, Block/Chunk/Octo/Voxel)*,
* поворота **Route** как целого адресного пути,
* поворота направлений (Dir6/Dir26, Octant),
* поворота плоских индексов и Morton-кода.

Цель Rotation — не добавить новую геометрию,
а гарантировать, что:

> **“тот же самый мир, те же самые адреса и контейнеры
> можно повернуть, не потеряв их смысл и структуру”.**

Rotation опирается на:

* каноническую систему осей `x | z | y` и иерархию уровней
  *(см. Topology)*;
* модель маршрутов и адресов Route
  *(см. Routing)*.

---

## **1.1. Назначение слоя Rotation**

Rotation вводит единый, строгий и обратимый набор правил для всех типов ротаций в системе:

* как корректно поворачивать **глобальные вектора** (signed XYZ);
* как поворачивать **локальные координаты** уровней:

  * Region-local координата,
  * Block / Chunk / Octochunk / Voxel;
* как поворачивать **Route** (адрес) и при этом
  не ломать его инварианты;
* как поворачивать **направления**:

  * знаковая модель октантов A–I,
  * дискретные направления Dir6/Dir26;
* как поворачивать **индексы**:

  * flat index (линейная память),
  * Morton-индекс (Z-order, SVO/LOD).

Слой Rotation нужен, чтобы:

* все подсистемы (генерация, редактор, DTO/HAOS, LOD/SVO, рендер)
  понимали повороты **одинаково**;
* можно было строить:

  * симметричные генерации,
  * поворотные блюпринты,
  * DYN-контейнеры и “плавающие куски мира”,
  * поворотные структуры в редакторе;
* любые операции “повернуть объект / область / шаблон”
  опирались на одну и ту же математику и инварианты.

---

## **1.2. Область применения**

Rotation не описывает геймплей и конкретную физику.
Он задаёт **математический контракт** для всех систем, которые используют повороты.

Примеры применения:

* **Генерация и блюпринты**

  * поворот заранее подготовленных структур (дом, комната, мост);
  * симметричные вариации: 4 ориентации одного и того же шаблона;
  * ориентирование паттернов относительно мира (север/юг/восток/запад).

* **DYN-контейнеры и локальные фигуры** *(будущий уровень)*

  * поворот целого контейнера с внутренней фигурой;
  * перенос фигур между разными ориентациями мира;
  * единые правила перехода “локальная сетка ↔ мировой Route”.

* **LOD/SVO и пространственные структуры**

  * поворот уровней вложенности без изменения Morton-логики;
  * симметричные деревья и пространственные кэши.

* **DTO/HAOS и управление активностью**

  * ориентация областей активности/наблюдения;
  * поворот “окон” симуляции вокруг игрока/камеры.

* **Редактор и инструменты**

  * поворот выделений (Chunk/Octo/Voxel-области);
  * копирование/вставка с изменённой ориентацией;
  * визуальный инспектор маршрутов и контейнеров с ротацией.

* **Рендер и буферы**

  * переориентация данных в GPU-буферах через flat/Morton-индексы;
  * поворот локальных воксельных мешей в рамках одной топологии.

---

## **1.3. Цели и ограничения Rotation**

Rotation сознательно ограничен и минималистичен,
чтобы оставаться стабильным фундаментом для всех последующих систем.

### **1.3.1. Цели**

* Обеспечить **строгую, дискретную** модель поворотов вокруг оси Y:

  ```
  { R0, R90, R180, R270 }
  ```

* Сделать поворот:

  * **обратимым**:
    `rot(rot(X, 90°), 270°) == X`;
  * **совместимым с топологией**:
    все координаты остаются в своих диапазонах;
  * **совместимым с Routing**:
    Route после ротации остаётся валидным адресом.

* Определить **минимальный набор операций**:

  * вращение координат (глобальных и локальных),
  * вращение Route,
  * вращение направлений (Octant, Dir6),
  * вращение индексов (flat, Morton),
  * вращение локальных кубов (VoxelRange / ChunkRange).

* Заложить основу для:

  * DYN-контейнеров (локальные миры, вращаемые целиком),
  * поворотных блюпринтов,
  * симметрий в генерации и оптимизациях.

---

### **1.3.2. Ограничения и то, чего здесь нет**

В рамках данного документа **Rotation**:

* использует **только дискретные повороты вокруг оси Y**
  (0° / 90° / 180° / 270°);
* не описывает произвольных 3D-ротаций (кватернионы, pitch/roll);
* не описывает:

  * сами DYN-контейнеры,
  * конкретные физические модели,
  * игровые механики.

Rotation считается:

> **низкоуровневой математической базой**
> для всех модулей, которые хотят что-то повернуть
> в рамках уже заданной топологии и маршрутизации.

---


# **2. Модель дискретной ротации**

Раздел 2 фиксирует **математическую модель поворотов**, на которой будут строиться все дальнейшие операции (ротация координат, Route, индексов и контейнеров).

Rotation рассматривается как дискретная группа поворотов вокруг вертикальной оси **Y**, действующая:

* на глобальные координаты `XYZ`,
* на локальные координаты уровней топологии,
* на направления (Octant, Dir6),
* на производные величины (индексы, диапазоны).

---

## **2.1. Канонический набор поворотов (группа C4)**

Слой Rotation использует конечное множество поворотов вокруг оси Y:

```text
R0   =  0°
R90  =  90°
R180 = 180°
R270 = 270°
```

Дальнейшие обозначения:

```text
Rot = { R0, R90, R180, R270 }
```

Эти повороты образуют циклическую группу порядка 4 (**C4**) с операцией композиции:

```text
R0   * θ  = θ
R90  * R90  = R180
R90  * R180 = R270
R90  * R270 = R0

R180 * R180 = R0
R270 * R90  = R0
...
```

Свойства:

* **Ассоциативность**: `(a * b) * c = a * (b * c)` для любых `a,b,c ∈ Rot`.
* **Тождественный элемент**: `R0` — не меняет аргумент.
* **Обратимый элемент**: для каждого `θ ∈ Rot` существует `θ⁻¹ ∈ Rot`, такой что:

  ```text
  θ * θ⁻¹ = R0
  ```

  Например:

  * `(R90)⁻¹ = R270`
  * `(R270)⁻¹ = R90`
  * `(R180)⁻¹ = R180`

Эта группа C4 является **единственным источником поворотов** в данном документе.
Любая операция Rotation принимает один из четырёх углов `{R0, R90, R180, R270}`.

---

## **2.2. Ось Y и плоскость XZ**

Ротации определяются **строго вокруг вертикальной оси Y**.

* Ось **Y** остаётся неизменной (инвариантная ось).
* Повороту подвергается только **плоскость XZ**.

Это согласуется с:

* каноническим порядком осей `x | z | y` (см. Topology);
* моделью, где XZ — основная рабочая плоскость террейна,
  а Y — вертикальный слой/высота.

### 2.2.1. Поворот глобального вектора (XYZ)

Пусть есть глобальный вектор:

```text
P = (X, Z, Y)
```

Для каждого θ ∈ {R0, R90, R180, R270} определены преобразования:

* **R0 (0°)**

  ```text
  (X', Z', Y') = (X, Z, Y)
  ```

* **R90 (90° вокруг Y)**

  ```text
  (X', Z', Y') = ( Z, -X, Y )
  ```

* **R180 (180°)**

  ```text
  (X', Z', Y') = ( -X, -Z, Y )
  ```

* **R270 (270°)**

  ```text
  (X', Z', Y') = ( -Z, X, Y )
  ```

Свойства:

* компонент **Y** сохраняется без изменений;
* `|P|` по XZ-проекции сохраняется (поворот — ортогональное преобразование);
* знаки X/Z меняются согласно направлению поворота.

Эти формулы используются:

* при ротации глобальных signed-координат;
* как основа для ротации локальных координат и направлений;
* в дальнейшем — при ротации Route и индексов.

---

## **2.3. Инварианты Rotation**

Все операции Rotation подчиняются общему набору инвариантов.

### **2.3.1. Обратимость**

Для любого объекта `T` (координата, Route, направление, индекс) и любого угла `θ`:

```text
rot(rot(T, θ), θ⁻¹) == T
```

где `θ⁻¹` — обратный угол из `{R0, R90, R180, R270}`.

Это требование:

* для глобальных XYZ-векторов;
* для локальных координат (Voxel/Octo/Chunk/Block/Region-local);
* для Route;
* для Flat/Morton-индексов;
* для диапазонов/локальных кубов.

### **2.3.2. Сохранение принадлежности контейнеру**

После применения Rotation к локальным координатам уровня:

* результирующие координаты остаются в допустимом диапазоне уровня;
* элемент остаётся внутри того же контейнера
  (одного и того же VoxelRange/Chunk/Block/Region).

Другими словами:

```text
rot(coord_local, θ) ∈ [0..size_x-1] × [0..size_z-1] × [0..size_y-1]
```

для соответствующего уровня.

Это позволяет:

* вращать содержимое контейнера, не меняя его размерности;
* безопасно переиндексировать буферы и структуры данных.

### **2.3.3. Согласованность с Topology / Routing**

Rotation не имеет права изменять:

* структуру иерархии `Region → Block → Chunk → Octochunk → Voxel`;
* порядок уровней в Route;
* диапазоны индексов каждого уровня.

Rotation:

* переориентирует координаты и индексы внутри уже заданных диапазонов;
* при ротации Route обязан сохранять его валидность:

  * Region остаётся Region,
  * Block остаётся Block и т.д.;
* не меняет инварианты, описанные в документах Topology и Routing.

### **2.3.4. Независимость от носителя данных**

Операции Rotation определяются:

* на уровне **координат и индексов**,
* а не на уровне конкретного формата хранения данных.

То есть:

* Rotation не зависит от того, хранятся ли данные:

  * в CPU-массиве,
  * в GPU-буфере,
  * в SVO-структуре,
  * в ECS-компонентах;
* он определяет только **как должны меняться координаты и индексы**,
  а переупорядочивание памяти — задача конкретной реализации.

---

# **3. Ротация координат**

Этот раздел описывает, как дискретные повороты `R0/R90/R180/R270` действуют:

* на **глобальные signed-координаты** мира (world-space XYZ),
* на **локальные индексные координаты** уровней топологии
  *(Region-local, Block, Chunk, Octochunk, Voxel)*,
* на **локальные float-координаты** внутри контейнера.

Здесь Rotation работает **чисто с числами**, без привязки к конкретным структурам данных.

---

## **3.1. Глобальные signed-координаты (world-space)**

Глобальные координаты описывают положение в мировом пространстве и могут быть отрицательными:

```text
P = (X_abs, Z_abs, Y_abs),  X_abs, Z_abs, Y_abs ∈ ℤ
```

Поворот вокруг оси Y действует только на плоскость XZ,
Y остаётся неизменной (см. 2.2).

### **3.1.1. Формулы поворота**

Для любого `P = (X, Z, Y)` и `θ ∈ {R0,R90,R180,R270}`:

* **R0 (0°)** — тождественное преобразование:

  ```text
  rot_world(P, R0) = ( X,  Z,  Y )
  ```

* **R90 (90° вокруг оси Y по часовой)**:

  ```text
  rot_world(P, R90) = (  Z, -X,  Y )
  ```

* **R180 (180°)**:

  ```text
  rot_world(P, R180) = ( -X, -Z,  Y )
  ```

* **R270 (270°)**:

  ```text
  rot_world(P, R270) = ( -Z,  X,  Y )
  ```

Свойства:

* `Y` не меняется.
* Длина вектора в XZ-проекции сохраняется.
* Поворот **обратим**:

  ```text
  rot_world(rot_world(P, θ), θ⁻¹) = P
  ```

Эти же формулы применимы и к **float-векторам**:

```text
(X, Z, Y) ∈ ℝ³
```

которые используются:

* физикой,
* навигацией,
* камерами,
* raycast и т.п.

---

## **3.2. Локальные индексные координаты уровней топологии**

Локальные координаты топологии (см. Topology) — всегда **неотрицательные индексы**:

```text
vx, vz, vy ≥ 0
ox, oz, oy ≥ 0
cx, cz, cy ≥ 0
...
```

Они живут внутри контейнеров фиксированного размера:

* Voxel внутри Octochunk,
* Octochunk внутри Chunk,
* Chunk внутри Block и т.д.

Rotation должен:

* поворачивать координаты **внутри контейнера**,
* гарантировать, что результат остаётся в диапазоне `[0..size-1]`,
* не менять размер контейнера.

### **3.2.1. Общая модель для XZ-плоскости контейнера**

Пусть есть контейнер с размерами:

```text
size_x = size_z = N
size_y = H      // высота уровня (может отличаться)
```

и локальная координата элемента:

```text
p = (x, z, y),  0 ≤ x < N,  0 ≤ z < N,  0 ≤ y < H
```

Тогда поворот вокруг оси Y описывается формулами:

* **R0 (0°)**

  ```text
  x' = x
  z' = z
  y' = y
  ```

* **R90 (90°)**

  ```text
  x' = z
  z' = N - 1 - x
  y' = y
  ```

* **R180 (180°)**

  ```text
  x' = N - 1 - x
  z' = N - 1 - z
  y' = y
  ```

* **R270 (270°)**

  ```text
  x' = N - 1 - z
  z' = x
  y' = y
  ```

Свойства:

* `(x',z')` всегда в диапазоне `[0..N-1] × [0..N-1]`;
* `y'` не изменяется;
* если считать контейнер квадратной матрицей XZ,
  то это обычный поворот матрицы на 0/90/180/270°.

Эта формула применяется **на всех уровнях**,
где контейнер имеет кубическую/квадратную XZ-сетку:

* Voxel-сетка внутри Octochunk (N = 32 или 64 и т.п.),
* Octochunk внутри Chunk (N = 2),
* Chunk внутри Block (N = 8),
* Block внутри Region (N = 8 по XZ, отдельная логика по Y).

---

### **3.2.2. Применение к конкретным уровням**

Для канонической конфигурации (см. Topology/1.2):

* **Voxel** внутри Octochunk:

  ```text
  N = OCTO_SIZE   // 32 (канон)
  (vx', vz', vy') = rot_local(vx, vz, vy, θ; N)
  ```

* **Octochunk** внутри Chunk:

  ```text
  N = 2           // 2×2×2 Octochunks
  (ox', oz', oy') = rot_local(ox, oz, oy, θ; N)
  ```

* **Chunk** внутри Block:

  ```text
  N = 8           // 8×8×8 Chunks
  (cx', cz', cy') = rot_local(cx, cz, cy, θ; N)
  ```

* **Block** внутри Region по XZ:

  ```text
  N = 8           // 8×8×2 Blocks
  (bx', bz')      = rot_local_xz(bx, bz, θ; N)
  by'             = by  // вертикальный индекс блока не меняется
  ```

Высота (`vy/oy/cy/by`) не изменяется при вращении вокруг оси Y.

---

### **3.2.3. Инварианты локальной ротации**

Для любого уровня и любой локальной координаты:

```text
p = (x,z,y)
p' = rot_local(p, θ; N)
```

гарантируется:

1. **Принадлежность контейнеру**

   ```text
   0 ≤ x' < N
   0 ≤ z' < N
   0 ≤ y' < H   // сохранение диапазона по высоте
   ```

2. **Обратимость**

   ```text
   rot_local(rot_local(p, θ; N), θ⁻¹; N) = p
   ```

3. **Согласованность с плоскими индексами**

   Если flat-index уровня (см. Topology/плоские индексы) определён как:

   ```text
   idx  = x + size_x * (z + size_z * y)
   ```

   то поворот может быть реализован:

   * либо через переиндексацию `(x,z,y) → (x',z',y') → idx'`,
   * либо через “таблицу ротации индексов” (precompute/lookup).

   В обоих случаях **семантика ротации координат остаётся одинаковой**.

---

## **3.3. Локальные float-координаты и их связь с топологией**

В дополнение к индексным координатам (целым), многие системы работают с **локальными float-координатами**, измеряемыми относительно:

* начала контейнера (Chunk/Block/Region),
* или произвольного origin внутри Route.

### **3.3.1. Локальный float в контейнере**

Пусть для некоторого контейнера определено локальное пространство:

```text
P_local = (x_f, z_f, y_f),  x_f, z_f, y_f ∈ ℝ
```

с диапазоном, согласованным с размером контейнера:

```text
0.0 ≤ x_f < N
0.0 ≤ z_f < N
0.0 ≤ y_f < H
```

Тогда поворот вокруг оси Y для float-координаты определяется **тем же** преобразованием, что и для мирового вектора:

* **R0**

  ```text
  (x_f', z_f', y_f') = ( x_f,  z_f,  y_f )
  ```

* **R90**

  ```text
  (x_f', z_f', y_f') = (  z_f,  N - 1.0 - x_f,  y_f )
  ```

* **R180**

  ```text
  (x_f', z_f', y_f') = ( N - 1.0 - x_f,  N - 1.0 - z_f,  y_f )
  ```

* **R270**

  ```text
  (x_f', z_f', y_f') = ( N - 1.0 - z_f,  x_f,  y_f )
  ```

Здесь мы явно учитываем границы `[0..N)` по XZ, чтобы:

* float-точка после поворота оставалась внутри того же контейнера,
* поведение совпадало с поворотом целочисленных индексов.

---

### **3.3.2. Мост: signed XYZ ↔ топология ↔ Rotation**

Общая схема работы с координатами под ротацией:

1. **Глобальный float-вектор (world-space)**

   ```text
   P_world = (X_abs, Z_abs, Y_abs) ∈ ℝ³
   ```

   может быть:

   * напрямую повернут: `rot_world(P_world, θ)`,
   * или преобразован в топологический адрес (см. Topology/Routing),
     затем Route подвергается ротации как структура.

2. **Топологический слой (индексы)**

   Вектор может быть разложен на:

   ```text
   Region, Block, Chunk, Octochunk, Voxel, локальные индексы
   ```

   После этого:

   * каждый уровень может быть повернут локально (см. 3.2),
   * либо весь Route будет повёрнут как единое целое (в следующих разделах).

3. **Локальный float в контейнере**

   При необходимости можно:

   * привязать float-вектор к origin контейнера (Region/Chunk/DYN),
   * повернуть его локально (см. 3.3.1),
   * затем по необходимости вернуть в мировое или топологическое пространство.

Таким образом:

> **одни и те же повороты θ ∈ {R0,R90,R180,R270}
> согласованно действуют на три слоя:**
>
> * глобальные signed-координаты (world-space),
> * локальные индексные координаты топологии,
> * локальные float-координаты контейнеров.

Это создаёт **единый язык ротации** для всего движка:
от физики и генерации до блюпринтов и будущих DYN-контейнеров.

---

# **4. Ротация направлений и октантов**

Этот раздел фиксирует, как дискретные повороты
`R0 / R90 / R180 / R270` действуют на:

* знаковую модель октантов **A–I** (см. Topology),
* дискретные направления **Dir6** (±X, ±Z, ±Y),
* и, при необходимости, более плотные наборы направлений.

Rotation не меняет топологию контейнеров —
он переопределяет **только ориентацию направления** в уже заданной системе осей `x | z | y`.

---

## **4.1. Типы направлений в системе**

В архитектуре используются три связанных слоя направлений:

1. **Octant (A–I)**
   Знаковая модель направления в пространстве:

   ```text
   (sx, sz, sy) ∈ {+1, -1}³
   ```

   Закодированная буквами:

   | Октант | sx | sz | sy |
   | ------ | -- | -- | -- |
   | A      | +  | +  | +  |
   | B      | −  | +  | +  |
   | C      | −  | −  | +  |
   | D      | +  | −  | +  |
   | E      | +  | +  | −  |
   | F      | −  | +  | −  |
   | G      | −  | −  | −  |
   | I      | +  | −  | −  |

2. **Dir6** — шесть осевых направлений:

   ```text
   +X, -X, +Z, -Z, +Y, -Y
   ```

3. **DirN / произвольные вектора**
   Любые signed-вектора `(dx, dz, dy)` ∈ ℤ³ / ℝ³,
   для которых направление определяется нормализацией.

Rotation должен действовать **одинаково** на всех этих уровнях,
опираясь на одну и ту же Y-ротацию (см. 2.2 / 3.1).

---

## **4.2. Ротация октантов A–I**

Октант — это **знаки осей**:

```text
Octant ↔ (sx, sz, sy),  sx, sz, sy ∈ {+1, -1}
```

Поворот вокруг оси Y:

* изменяет только X/Z компоненты `(sx, sz)`,
* **не меняет** знак `sy` (верх/низ).

### **4.2.1. Общие формулы для знаков**

Берём знак-вектор:

```text
S = (sx, sz) ∈ {+1, -1}²
```

Тогда для поворота вокруг оси Y:

* **R0 (0°)**

  ```text
  sx' = sx
  sz' = sz
  sy' = sy
  ```

* **R90 (90°)**

  ```text
  sx' =  sz
  sz' = -sx
  sy' =  sy
  ```

* **R180 (180°)**

  ```text
  sx' = -sx
  sz' = -sz
  sy' =  sy
  ```

* **R270 (270°)**

  ```text
  sx' = -sz
  sz' =  sx
  sy' =  sy
  ```

После вычисления `(sx', sz', sy')`
получаем новый октант по таблице соответствий (см. Topology).

---

### **4.2.2. Таблица ротаций октантов**

Для удобства реализации можно зафиксировать прямую таблицу `Octant × Rot → Octant`.

**Верхние октанты (sy = +)**

| θ    | A(+,+,+) | B(-,+,+) | C(-,-,+) | D(+,-,+) |
| ---- | -------- | -------- | -------- | -------- |
| R0   | A        | B        | C        | D        |
| R90  | D        | A        | B        | C        |
| R180 | C        | D        | A        | B        |
| R270 | B        | C        | D        | A        |

**Нижние октанты (sy = −)**

| θ    | E(+,+,−) | F(-,+,−) | G(-,-,−) | I(+,-,−) |
| ---- | -------- | -------- | -------- | -------- |
| R0   | E        | F        | G        | I        |
| R90  | I        | E        | F        | G        |
| R180 | G        | I        | E        | F        |
| R270 | F        | G        | I        | E        |

Свойства:

* вертикальная группа **(A–D)** никогда не смешивается с **(E–I)**;
* поворот — чистое “вращение” внутри верхнего или нижнего набора;
* для любого октанта:

  ```text
  rot_oct(rot_oct(oct, θ), θ⁻¹) == oct
  ```

---

### **4.2.3. Связь с signed-вектором**

Октант — это лишь сжатое представление направления signed-вектора.

Два эквивалентных способа ротации:

1. **Через знаковую модель** (таблица выше).

2. **Через signed-вектор**:

   * восстанавливаем произвольный вектор, совместимый с октантом:

     ```text
     v = (sx, sz, sy)
     ```

   * поворачиваем его как обычный вектор мира:

     ```text
     v' = rot_world(v, θ)
     ```

   * берём знак-компоненты `sign(v')` → новый октант.

Оба способа эквивалентны;
таблица — просто оптимизация для быстрого lookup.

---

## **4.3. Ротация Dir6 (осевые направления)**

Dir6 — минимальный набор дискретных направлений:

```text
+X, -X, +Z, -Z, +Y, -Y
```

Поворот вокруг оси Y:

* оставляет `+Y / -Y` неизменными,
* вращает `±X / ±Z` в плоскости XZ.

### **4.3.1. Таблица ротаций Dir6**

Пусть Dir6 представлен, например, enum’ом:

```rust
enum Dir6 {
    PosX, NegX,
    PosZ, NegZ,
    PosY, NegY,
}
```

Тогда:

**R0 (0°)**

```text
PosX → PosX
NegX → NegX
PosZ → PosZ
NegZ → NegZ
PosY → PosY
NegY → NegY
```

**R90**

```text
PosX → PosZ
PosZ → NegX
NegX → NegZ
NegZ → PosX

PosY → PosY
NegY → NegY
```

**R180**

```text
PosX → NegX
NegX → PosX
PosZ → NegZ
NegZ → PosZ

PosY → PosY
NegY → NegY
```

**R270**

```text
PosX → NegZ
NegZ → NegX
NegX → PosZ
PosZ → PosX

PosY → PosY
NegY → NegY
```

Свойства:

* вертикальные направления не меняются;
* горизонтальные направления вращаются по тем же правилам,
  что и XZ-компоненты векторов (см. 3.1).

---

## **4.4. Ротация произвольных дискретных направлений (DirN)**

Для более плотных наборов направлений (например, Dir26 — все соседи в воксельной решётке)
Rotation не нуждается в отдельной таблице.

Общий принцип:

1. Любое направление представляется как signed-вектор:

   ```text
   D = (dx, dz, dy) ∈ ℤ³
   ```

   (например, `(-1, 0, +1)` для диагонали “влево-вперёд-вверх”).

2. Применяется поворот как к мировому вектору:

   ```text
   D' = rot_world(D, θ)
   ```

3. Если нужно вернуться к дискретному набору (Dir26/DirN) —
   используется нормализация/квантование по принятому правилу.

Rotation в этом случае:

* полностью повторяет модель для координат (3.1),
* не требует узнавать что-то о конкретном DirN,
* остаётся независимым от того, сколько направлений выбрал движок.

---

## **4.5. Инварианты ротации направлений**

Для всех типов направлений (Octant, Dir6, DirN):

1. **Обратимость**

   ```text
   rot_dir(rot_dir(D, θ), θ⁻¹) == D
   ```

2. **Согласованность с векторами**

   Если направление представлено как вектор `v` и как дискретный символ `D`, то:

   ```text
   rot_world(v, θ) соответствует rot_dir(D, θ)
   ```

   (после нормализации/знаковой интерпретации).

3. **Согласованность с Topology / Routing**

   * Октант после ротации остаётся корректным октантом A–I.
   * Dir6/DirN остаются внутри своих множеств.
   * Маршруты, которые используют Octant или Dir6 как часть состояния,
     имеют возможность поворачиваться строго по этим правилам
     (см. следующие разделы про Rotation для Route).

## **4.6. Справочная таблица наборов направлений (Dir6 / Dir18 / Dir26)**

В воксельной решётке часто используют несколько стандартных наборов дискретных направлений:

| Набор   | Кол-во | Что включает                              | Интуиция                                  |
|--------|--------|--------------------------------------------|-------------------------------------------|
| **Dir6**  | 6      | Только осевые соседи: ±X, ±Y, ±Z          | «По граням куба» (ортогональные шаги)     |
| **Dir18** | 18     | Dir6 + соседи по рёбрам                   | «Грани + рёбра» без диагональных углов    |
| **Dir26** | 26     | Dir18 + угловые соседи (по вершинам)      | Полная 3D-связность вокруг вокселя       |

Во всех случаях:

* направления можно представить как целочисленные вектора `(dx, dz, dy) ∈ {−1, 0, +1}³`, кроме `(0,0,0)`;
* Rotation действует одинаково:
  * направление → вектор `(dx, dz, dy)`,
  * поворот `rot_world(d, θ)` вокруг оси Y,
  * при необходимости — нормализация обратно в соответствующий набор (Dir6/Dir18/Dir26).

Таким образом, модель Rotation не привязана жёстко к какому-то одному набору,
а задаёт единые правила поворота для любых дискретных направлений над воксельной решёткой.


---

# **5. Ротация Route и контейнеров**

Раздел 5 описывает, как дискретные повороты
`R0 / R90 / R180 / R270` действуют:

* на **Route** — канонический адрес (см. Routing),
* на **позицию контейнера** в мире,
* на **внутреннее содержимое контейнера** (воксельные кубы, чанки и т.п.).

Здесь Rotation становится мостом:

> между **мировыми координатами XYZ**,
> **топологией** (Region/Block/Chunk/Octo/Voxel)
> и **данными контейнеров**.

---

## **5.1. Каноническая ротация Route (через XYZ)**

Базовое определение ротации Route даётся **через мировые координаты**.

Пусть есть Route:

```text
Route {
    region: (rx, rz, ry),
    octant: Octant,
    block:  Option<BlockCoord>,
    chunk:  Option<ChunkCoord>,
    octo:   Option<OctoCoord>,
    voxel:  Option<VoxelCoord>,
}
```

Тогда **каноническая ротация Route** определяется в три шага:

1. **Decode: Route → XYZ**

   Используем формулы из Topology/формулы переходов:

   ```text
   (X, Z, Y) = route_to_xyz(route)
   ```

2. **Rotate: XYZ → XYZ'**

   Применяем дискретный поворот вокруг оси Y (см. 3.1):

   ```text
   (X', Z', Y') = rot_world((X, Z, Y), θ)
   ```

3. **Encode: XYZ' → Route'**

   Обратно раскладываем мировую координату в топологию (см. Topology/обратные переходы):

   ```text
   route' = xyz_to_route(X', Z', Y')
   ```

Обозначение:

```text
route' = rot_route_world(route, θ)
```

Свойства:

* Route' **всегда валиден** с точки зрения топологии;
* структура уровней (`Region/Block/Chunk/...`) сохраняется;
* все инварианты Routing остаются истинными;
* операция **обратима**:

  ```text
  rot_route_world(rot_route_world(route, θ), θ⁻¹) == route
  ```

Это определение — **канон**:
любая оптимизированная реализация (через индексы, таблицы, Morton и т.п.)
должна давать тот же результат, что и цепочка `Route → XYZ → Rotation → Route`.

---

## **5.2. Локальная ротация внутри контейнера (Route как якорь)**

Частый сценарий:

* Route используется как **якорь контейнера**
  (например, Chunk/Block/Region или будущий DYN-контейнер),
* содержимое контейнера хранится в локальных координатах/индексах,
* нужно повернуть **только внутреннюю структуру**,
  не меняя глобальную позицию Route.

В этом случае:

* **Route остаётся неизменным**;
* локальные координаты содержимого вращаются по `rot_local(...)` (см. 3.2).

Пример: поворот содержимого Chunk при фиксированном Route чанка:

```text
// Route чанка остаётся тем же
chunk_route' = chunk_route

// Для каждого локального вокселя:
(vx, vz, vy)   → (vx', vz', vy') = rot_local(vx, vz, vy, θ; N = 64)
```

Свойства:

* контейнер “стоит на месте” в мировом пространстве;
* внутренняя геометрия поворачивается внутри своего объёма;
* используем те же формулы, что для локальных координат (3.2 / 3.3).

Такой режим используется для:

* поворота блюпринтов/структур внутри заранее выбранного чанка/блока,
* перестройки локальной геометрии без переноса контейнера в мире,
* симметричных вариаций контента.

---

## **5.3. Позиция контейнера vs содержимое: два независимых слоя**

Важно разделять два разных типа ротации:

1. **Ротация позиции контейнера в мире**
   (перемещение чанка/блока/контейнера как целого):

   * Route вращается по правилу `rot_route_world(route, θ)`,
   * внутреннее содержимое может *оставаться как есть*.

   Это похоже на “мы перенесли эту же геометрию в другую ориентацию мира”.

2. **Ротация содержимого контейнера**
   (локальный поворот данных внутри):

   * Route не меняется,
   * локальные координаты содержимого вращаются через `rot_local`.

Практически:

```text
// Вариант A: повернуть “куда смотрит” контейнер (его позицию)
route_world_rotated = rot_route_world(route, θ)

// Вариант B: повернуть “что внутри” (геометрию)
data_rotated_by_local_indices(...)
```

Оба варианта могут быть **скомбинированы**:

* сначала повернули содержимое,
* потом перенесли контейнер в новое положение (или наоборот),
* при этом обе операции опираются на одни и те же θ и те же формулы.

---

## **5.4. Ротация базовых контейнеров топологии**

Используя 3.2 и 5.2, фиксируем стандартную модель ротации для контейнеров:

### **5.4.1. VoxelRange (локальный куб)**

Любой кубовый диапазон вокселей (например, `32×32×32` или `64×64×64`)
вращается через `rot_local`:

```text
for each (vx, vz, vy) in [0..N) × [0..N) × [0..H):
    (vx', vz', vy') = rot_local(vx, vz, vy, θ; N)
```

Применение:

* локальные структуры,
* фрагменты геометрии,
* мини-шаблоны внутри чанка/окточанка.

---

### **5.4.2. Octochunk**

Octochunk состоит из `N×N×N` вокселей (N=32 по канону)
и сам является одним из `2×2×2` под-чанков.

**Поворот содержимого Octochunk:**

* Route Octochunk фиксирован,
* применяем `rot_local` к вокселям внутри.

**Поворот позиции Octochunk внутри Chunk:**

* Route чанка фиксирован,
* координата `(ox, oz, oy)` меняется:

  ```text
  (ox', oz', oy') = rot_local(ox, oz, oy, θ; N = 2)
  ```

---

### **5.4.3. Chunk**

Chunk включает:

* **позицию** внутри блока `(cx, cz, cy)` (N=8),
* **содержимое** — воксельный объём `64×64×64` (по канону).

**Поворот позиции чанка внутри Block:**

```text
(cx', cz', cy') = rot_local(cx, cz, cy, θ; N = 8)
```

**Поворот содержимого чанка:**

```text
(vx', vz', vy') = rot_local(vx, vz, vy, θ; N = 64)
```

---

### **5.4.4. Block и Region (по XZ)**

Block:

* позиция внутри Region по XZ:

  ```text
  (bx', bz') = rot_local(bx, bz, θ; N = 8)
  by'        = by
  ```

Region-local:

* если рассматриваем локальную Region-сетку `[0..REGION_SIZE_XZ)` по XZ,
  к ней может быть применён тот же `rot_local` (с N = REGION_SIZE_XZ),
  когда речь идёт о **ротации содержимого внутри региона**.

**Важно:** при полной ротации Route (5.1)
пересчёт регионов и локальных координат идёт через XYZ,
а не напрямую через `rot_local` — это даёт корректное поведение на бесконечной сетке.

---

## **5.5. Инварианты ротации Route и контейнеров**

Для всех операций из этого раздела сохраняются следующие свойства.

### **5.5.1. Route ↔ XYZ**

Каноническая ротация Route всегда удовлетворяет:

```text
route' = rot_route_world(route, θ)

decode(encode(route')) == route'
```

и

```text
rot_route_world(rot_route_world(route, θ), θ⁻¹) == route
```

Где `encode/decode` — функции Topology/ Routing для перехода Route ⇄ XYZ.

---

### **5.5.2. Согласованность локальной и мировой ротации**

Если:

* мы декодируем Route в XYZ,
* поворачиваем XYZ,
* и нормализуем его обратно в локальные координаты контейнеров,

то результат **эквивалентен** по смыслу последовательности:

* `rot_local` на уровнях (Voxel / Octo / Chunk / Block),
* плюс корректный пересчёт Region/Octant.

Это позволяет:

* выбирать удобный уровень реализации (через Route / через индексы),
* не терять согласованность между реализациями.

---

### **5.5.3. Неприкосновенность инвариантов Topology / Routing**

Ни одна операция Rotation:

* не изменяет порядок уровней,
* не вводит отрицательные локальные координаты,
* не нарушает диапазоны индексов,
* не разрушает биекцию Route ⇄ XYZ.

Rotation — чистый **слой преобразований ориентации**,
который использует уже заданную топологию и маршрутизацию,
но **не меняет их структуру**.

---

# **6. Итог раздела Rotation**

Раздел Rotation задаёт **единый, строгий и минимальный контракт поворотов** для всего движка.
Он не меняет топологию и маршрутизацию, а описывает, **как их объекты поворачиваются в пространстве**.

---

## **6.1. Что зафиксировано моделью Rotation**

1. **Группа поворотов**

   Используется конечное множество поворотов вокруг вертикальной оси:

   ```text
   Rot = { R0, R90, R180, R270 }
   ```

   Это дискретная группа C4 с обычной композицией поворотов и обратимыми элементами.

2. **Ось Y — инвариантная**

   * Повороты определены **строго вокруг оси Y**.
   * Компонента Y для координат и направлений **не изменяется**.
   * Вращается только плоскость XZ.

3. **Порядок осей**

   Везде сохраняется канон:

   ```text
   x | z | y
   ```

   Rotation не вводит альтернативных систем координат, а работает строго поверх этой.

---

## **6.2. Связь с Topology и Routing**

Rotation опирается на уже определённые:

* **Topology**:

  * иерархия `Region → Block → Chunk → Octochunk → Voxel`,
  * диапазоны индексов и страйды,
  * модель октантов и знаков.

* **Routing**:

  * Route как канонический адрес,
  * инварианты Route ⇄ XYZ,
  * маски уровней и сокращённые маршруты.

Основные принципы:

1. **Ротация Route через XYZ — канон**

   Любая “правильная” ротация Route определяется цепочкой:

   ```text
   Route → XYZ → rot_world(θ) → XYZ' → Route'
   ```

   Любая оптимизация (через индексы, таблицы, Morton и т.д.)
   обязана быть эквивалентна этому канону.

2. **Структура иерархии не меняется**

   Rotation:

   * не меняет порядок уровней,
   * не нарушает диапазоны индексов,
   * не вводит отрицательные локальные координаты,
   * не разрушает биекцию Route ⇄ XYZ.

   Он только **меняет ориентацию** в рамках уже заданной структуры.

---

## **6.3. Уровни, на которых действует Rotation**

Rotation описан единообразно для трёх слоёв:

1. **Глобальные координаты (world-space XYZ)**

   * signed-вектора `(X, Z, Y) ∈ ℤ³ / ℝ³`,
   * физика, навигация, камеры, raycast.

2. **Топологические локальные координаты (индексы ≥ 0)**

   * `(vx, vz, vy)`, `(ox, oz, oy)`, `(cx, cz, cy)` и т.д.,
   * локальная ротация внутри контейнера через `rot_local`,
   * гарантированное сохранение диапазонов и принадлежности контейнеру.

3. **Локальные float-координаты контейнеров**

   * `(x_f, z_f, y_f) ∈ [0..N)×[0..N)×[0..H)`,
   * та же геометрия поворота, что и для индексов, но в float’ах.

Отдельно зафиксировано поведение для:

* **направлений**:

  * октанты A–I,
  * Dir6 (±X, ±Z, ±Y),
  * произвольные DirN через rot_world + нормализацию;

* **Route и контейнеров**:

  * поворот позиции Route в мире,
  * поворот содержимого контейнера при фиксированном Route,
  * возможность комбинировать оба сценария.

---

## **6.4. База для DUN-контейнеров и сложных фигур**

Хотя сам раздел Rotation **не описывает** Dynamic Unit Node-контейнеры, он даёт им готовую базу:

1. **Якорь контейнера**

   * DUN-контейнер может иметь Route (Region/Block/Chunk/…),
   * его *позиция в мире* поворачивается через `rot_route_world`.

2. **Локальное содержимое**

   * внутренняя фигура/воксельный объём живут в собственных локальных координатах,
   * к ним применяется `rot_local` или rot_world для float.

3. **Независимое управление**

   * можно крутить только якорь (меняем ориентацию в мире),
   * можно крутить только содержимое (смена формы внутри контейнера),
   * можно крутить оба согласованно одной и той же θ.

Таким образом, Rotation уже задаёт:

> единый “язык поворотов” для будущих DUN-контейнеров
> без необходимости менять топологию или routing.

---

## **6.5. Контракт для реализаций и тестирования**

Для любого модуля движка, использующего Rotation (DTO, HAOS, LOD/SVO, генерация, ECS, рендер, редактор), действуют общие условия:

1. **Эквивалентность канону**

   Любое ускоренное/специализированное вычисление ротации должно быть эквивалентно:

   ```text
   Route → XYZ → rot_world(θ) → XYZ' → Route'
   ```

2. **Обратимость**

   Для всех сущностей:

   ```text
   rot(rot(T, θ), θ⁻¹) == T
   ```

   где T — координата, направление, Route, локальный индекс.

3. **Сохранение диапазонов**

   Все локальные координаты после ротации остаются в допустимых диапазонах уровня.

4. **Согласованность слоёв**

   Ротация:

   * направлений ↔ векторов,
   * локальных индексов ↔ Route ↔ XYZ,
   * контейнеров ↔ их содержимого

   должна быть согласованной и предсказуемой.

---

**Итог по Rotation**

Мы получили:

* компактную, дискретную модель поворотов вокруг Y (C4),
* формулы для всех типов координат и направлений,
* каноническую ротацию Route и контейнеров,
* инварианты, совместимые с Topology и Routing,
* прочный фундамент для DYN-контейнеров, симметричных структур и блюпринтов.

На этом **триада документов**:

* Topology,
* Routing,
* Rotation

формирует цельный мат-слой пространства:
*как мир делится, адресуется и поворачивается.*

---
