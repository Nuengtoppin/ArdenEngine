## MINI/README

Здесь собран весь глоссарий терминов в рамках проекта.

разделил на: 
 - Custom Terms
 - General Terms
 - Mesh & Surface Extraction
 - BVH Terms


по мере развития глоссарий будет пополняться, изменяться, редактироваться 

---

## Custom Terms 
Содержит внутренние термины архитектуры мира, модулей и подсистем:

---

### **Butler — логгер-валидатор ядра**

**Описание:** служба контроля целостности. Проверяет состояние модулей, собирает логи, анализирует перегрузки шины BUS, сообщает об ошибках и предлагает исправления. Может автоматически решать простые несоответствия.
**Аналоги:** closest — watchdog/diagnostics system, но Butler — часть архитектуры и работает как «умный валидатор».

---

### **Aspectrolog — семантическая библиотека аспектов**

**Описание:** модуль семантики мира (на ранней стадии концепта). Хранит «аспекты» — описания свойств, категорий и поведения объектов: *огонь, вода, газ, металл, биология и т.п.*

Используется как расширяемый словарь свойств для модулей HAOS и EQ-Sim и таких как:

* процедурной генерации поведения,
* подсказок оптимизаций,
* кастомных правил мира.
  **Аналоги:** нет прямого; частично похоже на теги/traits в ECS или rule-based systems.

*(Отмечено: концепт сырой, допустимо обновить позже.)*

---

### **DTO — Dormant tick observer**

**Описание:** концепт сна и активности. Элемент мира (контейнер, окточанк, сабчанк) считается **ACTIVE**, если он участвует в тике или изменениях, и **DORMANT**, если «спит», но может быть пробуждён HAOS или DYN.
**Аналоги:** Unity Sleeping bodies, ECS Dirty flags.

---

### **HAOS — Hybrid Adaptive Optimization System**

**Описание:** надстройка оптимизаций над EQ. Содержит модульную библиотеку (`HAOS lib`) алгоритмов, которые включаются динамически по состоянию мира. Работает поверх EQ-Sim, оптимизируя потоки данных.
**Типы оптимизаций:**

* **Spatial:** LOD, SVO, decimation
* **Temporal:** tick scheduling, batching
* **Culling:** distance/visibility
* **Memory:** archiving / awakening (DTO)

#### **HAOS-lib**

Коллекция алгоритмов оптимизаций, доступная HAOS-модулю.
Включает Spatial/Temporal/Culling/Memory техники.

---

## **DUN — Dynamic Unit Node / динамический узел**

**Описание:**  
Базовый подвижный элемент архитектуры, объединяющий воксельную структуру, mesh, физику и runtime-поведение.  
DUN несёт локальные данные (volume, bounds, transform) и может быть статичным или динамическим.  
Движется как единое целое, не нарушая дискретную топологию мира.

**Типы:**  
* **Static DUN** — закреплён в пространстве, часть статической топологии.  
* **Dynamic DUN** — подвижный, имеет собственную физику и состояние активности.

**Аналоги:** dynamic chunk, rigid voxel body, но DUN — формализованный узел ядра, связывающий топологию и физику.

---

### **EQ** Equilibrium Kernel

#### **EQ-Core — Equilibrium Core / ядро равновесия** = данные мира

**Описание:** чистая модель состояния мира. Хранит гибридные данные: воксели, векторные структуры, топологию, контейнеры и системные теги. Эквивалент «памяти мира» без выполнения логики.
**Аналоги:** ECS-World / Scene State, но с поддержкой воксельно-векторного гибрида.


#### **EQ-Sim — Equilibrium Simulator / симулятор равновесия** = поведение мира

**Описание:** исполнитель правил мира. Читает EQ-Core, применяет обновления и логические процессы, формируя корректное и согласованное состояние перед рендером и оптимизациями.
**Аналоги:** игровой «executor», gameplay loop, но глубже встроен в ядро.

---

### **BUS — Coordinator Bus / координационная шина**

**Описание:** главный оркестратор данных между модулями ядра. Не исполняет тяжёлых задач — только маршрутизирует события и состояния.
**Аналоги:** event bus / scheduler / orchestrator.

---

## **General Terms** (Общие технические термины)

Содержит термины, используемые в индустрии графики, рендеринга и воксельных движков:


### **DAG — Directed Acyclic Graph / направленный ацикличный граф**

**Описание:** граф зависимостей без циклов. Используется для оптимизации вычислений, построения LOD-иерархий, маршрутов и цепочек обновлений.
**Аналоги:** Blender node graph, task graphs в движках.

---

### **AABB — Axis-Aligned Bounding Box**

**Описание:** бокс, выровненный по осям XYZ. Используется для быстрых проверок столкновений, broad-phase поиска и spatial-оптимизаций.
**Аналоги:** классика PhysX/Havok/ECS.

### **OBB — Oriented Bounding Box**

**Описание:** бокс произвольной ориентации. Точнее, чем AABB, но дороже в расчётах; применяется для сложных динамических форм.
**Аналоги:** SAT/Separating Axis Theorem.

---

### **LOD — Level of Detail / уровень детализации**

**Описание:** система подмены данных (мешей, вокселей, геометрии) на упрощённые уровни при увеличении distance/углов видимости/нагрузки.
**Аналоги:** Unity LODGroup, Unreal LODs.

---

### **Octree**

**Описание:** структура, которая делит пространство на 8 частей на каждом уровне. Оптимальна для вокселей, пространственного поиска и LOD.
**Комментарий:** фундамент твоей иерархии Region→Chunk→Octochunk→Subchunk.
**Где встречается:** voxel engines, 3D-навигация, физика, GI.

### **Loose Octree**

**Описание:** версия octree, где узлы увеличены по размеру, чтобы динамические объекты не ломали границы.
**Комментарий:** подходит для подвижных контейнеров (как DYN), снижая количество перестроений.
**Где встречается:** физические движки, dynamic object trees.

---
### **Cascaded Voxel Grid**

**Описание:** воксельная сетка в нескольких масштабах для дальнего освещения, теней и GI.
**Комментарий:** гибридная техника, в теории сочетается с HAOS (spatial).
**Где встречается:** voxel cone tracing, VXGI, большие GI-системы.

---

### **Clipmap**

**Описание:** слойная структура хранения пространства: близко — плотный слой, дальше — разреженные уровни детализации.
**Комментарий:** полезно для огромных миров или многоуровневых LOD поверх воксельной сцены.
**Где встречается:** VXGI, terrain engines, cascaded maps.

### **Clipmap LOD**

**Описание:** многоуровневая система LOD, где каждая зона мира хранится в нескольких разрешениях по мере удаления от игрока.
**Комментарий:** облегчает работу с огромными сценами и идеально ложится поверх воксельной структуры.
**Где встречается:** terrain engines, VXGI, large-world renderers.

---

### **Sparse Voxel Octree (SVO) — variants**

**Описание:** разреженные октодеревья, где хранятся только занятые узлы; возможны варианты с компрессией, Mip-уровнями и GPU-ускорением.
**Комментарий:** подходит для GI, рейтрейсинга, крупных воксельных миров; можно использовать как дополнительный уровень поверх Octochunk.
**Где встречается:** Atomontage, GigaVoxels, voxel GI.

---

### **Space-Filling Curves — Hilbert Curve**

**Описание:** кривая, проходящая через всё пространство так, что соседние точки в 3D остаются соседними в 1D порядке.
**Комментарий:** даёт лучшую локальность, чем Morton, но считается тяжелее; может использоваться в HAOS для spatial-оптимизаций.
**Где встречается:** базы данных, GPU-рендер, memory-tiling.

---

### **SDF — Signed Distance Field**

**Описание:**
Поле расстояний, где каждое значение хранит дистанцию до ближайшей поверхности (положительное/отрицательное). Используется для плавных поверхностей, коллизий и генерации мешей.
**Где встречается:**
Godot SDFGI, Unreal Distance Fields, VFX-симуляции.
**Комментарий:**
может использоваться как вспомогательный формат для Mesh Layer или HAOS (spatial-оптимизации).

### **Voxel GI — воксельное глобальное освещение**

**Описание:**
Метод освещения, где свет и отражения записываются в воксельную сетку и обновляются по сцене.
**Где встречается:**
Godot GIProbe (старый), VXGI (NVIDIA), sparse-voxel GI техники.
**Комментарий:**
может быть применим как отдельный модуль поверх Mesh Layer / SVO

---

### OpenVDB — sparse volume grid library

**Описание:** открытая библиотека DreamWorks для хранения и обработки больших разреженных воксельных объёмов (дым, SDF, плотности). Используется в VFX и offline-render.
**Аналоги:** NanoVDB (GPU-версия).
Комментарий: не подходит для real-time игровых движков; слишком тяжёлое и не ориентировано на динамическое обновление малыми блоками.

---

### **Z-Curve Hashing (Morton Hashing)**

**Описание:** представление 3D-координат в виде хэша на основе Morton-кода, обеспечивающего локальность.
**Комментарий:** полезно для быстрых словарей, spatial-таблиц, индексации окточанков.
**Где встречается:** LBVH, GPU voxel engines, SVO.

### **Morton Codes / Z-Order**

**Описание:** способ превратить 3D-координаты в одно число через чередование битов, сохраняя пространственную близость. Упрощает сортировку и ускоряет пространственные структуры.
**Комментарий:** используется в Arden внутри маршрутизации и топологии для компактного адреса пространства.
**Где встречается:** LBVH, SVO, GPU-рендер, voxel engines.

### **KD-Tree (k-d tree)**

**Описание:** дерево, которое делит пространство по оси X→Y→Z по циклу, позволяя быстро находить ближайшие точки и объекты.
**Комментарий:** полезно для поиска соседей, навигации и подбора ближайших мешей/контейнеров.
**Где встречается:** AI, геометрия, ray tracing, ускорители поиска.

---

### **ECS — Entity Component System**

**Описание:**
Архитектурный подход, где мир представлен сущностями (Entity), их данными (Component) и системами обработки (System). Обеспечивает плотное хранение, разделение данных/логики и высокую производительность при массовых операциях.

**Где встречается:**

* **Bevy** — чистый ECS-движок (твоя основная платформа).
* **Unity DOTS** — экспериментальная ECS-подсистема (не основной runtime).
* **Frostbite (EA)** — использует ECS-подобную модель данных.
* **Amethyst / Fyrox / Specs** — движки на Rust с ECS-ядром.
* **EnTT, Flecs** — популярные standalone ECS-библиотеки.

**Комментарий:**
В большинстве классических движков (Unreal, Godot, Unity-standard) ECS *не является основой*, а присутствует лишь как концепт.

---

### **Mesh Layer — слой генерации и хранения мешей**

**Описание:**
Промежуточный слой между воксельной топологией и GPU.
**Где встречается:**
* **Minecraft-подобные движки** — mesh extraction из чанков (Greedy Meshing, Marching Cubes и др.).
* **Godot / Unity / Unreal** — mesh builder API, но не как отдельный слой.
* **GigaVoxels / Dual Contouring engines** — плотная интеграция вокселей в меши.

**Комментарий:**
В классических движках Mesh Layer — просто инструмент.

Может обьединять:

* векторный слой,
* surface-генерацию,
* GPU-буферы,
* оптимизации HAOS (spatial/LOD).

Он фактически является мостом Vox ↔ Render.

---

#### **Triangulation — триангуляция**

**Описание:**
Преобразование поверхности или вокселей в треугольную mesh-сетку для рендера.
**Где встречается:**
Marching Cubes, Dual Contouring, Surface Nets; используется во всех воксельных и mesh-движках.
**Комментарий:**
  для генерации GPU-мешей из окточанков/сабчанков.

---

#### **Marching Cubes**

**Описание:**
Алгоритм извлечения поверхности из воксельного поля путём выборки кубов и триангуляции их границ.
**Где встречается:**
Voxel-энджины, мед. визуализация, Blender.
**Комментарий:**
 один из возможных методов поверхностной генерации в Mesh Layer.

---

#### **Dual Contouring**

**Описание:**
Алгоритм получения сетки из вокселей с сохранением острых граней и топологии.
**Где встречается:**
Графические и геометрические движки, voxel GI.
**Комментарий:**
 для более ровных и точных поверхностей.

---

#### **Surface Nets**

**Описание:**
Метод сглаженного извлечения поверхности через сетку точек и простые связи между ними.
**Где встречается:**
Лёгкие voxel-рендеры, научная визуализация.
**Комментарий:**
 быстрый вариант для low-detail LOD.

---

#### **Greedy Meshing**

**Описание:**
Оптимизация, которая объединяет большие плоскости вокселей в крупные полигоны для уменьшения количества треугольников.
**Где встречается:**
Minecraft-подобные движки, cubic voxel engines.
**Комментарий:**
 при плотных блоковых поверхностях (кубическая геометрия).

---

### **GPU/WGPU Layer**

**Описание:** нижний слой рендера, принимающий меши, буферы и текстуры.
**Где встречается:** WGPU, современные GPU-движки.

---

### **BVH — Bounding Volume Hierarchy**

**Описание:**
Дерево объёмов (обычно AABB), ускоряющее поиск коллизий, выбор объектов и рейтрейсинг. Повышает скорость пространственных операций за счёт иерархического отсечения.

**Где встречается:**
NVIDIA RTX, Unreal, Unity Physics, Blender, Embree, OptiX.
Стандартный алгоритм в графике и физике.

**Комментарий:**
Не является частью Arden, но может использоваться как расширение HAOS-lib для spatial-оптимизаций/DYN

**Дополнительные термины** (опционально)

---

#### **BVH2 / BVH4 / BVH8**

Разновидности BVH, отличающиеся количеством дочерних узлов (2, 4 или 8).
Используются в рейтрейсинге и быстрых spatial-структурах (RTX, Embree).

---

#### **SAH — Surface Area Heuristic**

Эвристика, определяющая, как лучше разбить узлы BVH для минимизации пересечений.
Стандартный критерий качества BVH в рендерерах и трассировщиках.

---

#### **LBVH — Linear BVH**

Метод построения BVH по Morton-кодам для очень быстрого (GPU) создания и обновления дерева.
Применяется в GPU-рейтрейсинге и real-time voxel GI.

---

####  **HLBVH — Hierarchical LBVH**

Улучшенный LBVH: быстрый нижний уровень строится линейно, верхний — SAH.
Даёт баланс скорости (GPU) и качества дерева.

---

#### **ABVH / Dynamic BVH**

BVH, который можно частично обновлять при движении объектов (не перестраивая всё дерево).
Используется в физике и играх для динамических сцен (Havok, Bullet).

---

