# **1.0. Обзор / mini-README раздела топологии**

Этот раздел задаёт **фундаментальную топологию мира** — строгий язык, в котором описывается пространство движка:

* как мир разбивается на контейнеры (Region → Block → Chunk → Octochunk → Voxel),
* какие у них размеры и страйды,
* как устроены координаты и индексы,
* как из адреса получить позицию в мире и обратно,
* как 3D-координаты линейно отображаются в 1D-память (flat index, Morton).

Раздел **не описывает** геймплей, генерацию контента, сетевой код, DTO/HAOS и другие подсистемы.
Здесь фиксируется только **чистая математика пространства**, одинаковая для всех уровней R&D.

---

## 1.0.1. Что задаёт топология

Раздел 1.x формирует:

* **Единый язык пространства**
  * жёсткая иерархия контейнеров: `Region → Block → Chunk → Octochunk → Voxel`;
  * фиксированные правила вложенности и кратности уровней;
  * возможность масштабировать плотность (32³ / 64³ / 128³) без изменения структуры.

* **Координатную модель**
  * канонический порядок осей `x | z | y`;
  * разделение на глобальные (signed / float) координаты и локальные индексы ≥ 0;
  * знаковую модель через октанты A–I;
  * мост между мировыми координатами и топологией (Region + LocalFloat).

* **Адресацию и индексацию**
  * иерархические индексы и страйды для всех уровней;
  * прямые и обратные формулы преобразования адрес ↔ координата;
  * плоские индексы (flat index) для линейной памяти;
  * Morton-порядок для SVO/LOD и пространственных деревьев.

Этого достаточно, чтобы:

* однозначно адресовать любой воксель или контейнер,
* собрать/разложить координаты в любом направлении,
* построить поверх топологии routing, LOD, SVO, DTO/HAOS, стриминг и прочие системы.

---

## 1.0.2. Структура раздела 1.x (по блокам)

**1.1. Уровни иерархии**  
Вводит пять уровней топологии:

> Region → Block → Chunk → Octochunk → Voxel

и описывает их **логические роли**:
корневой контейнер мира, статический блок, основной носитель плотных данных, структурный под-контейнер и атомарный воксель.  
Фиксирует, что иерархия неизменна, но может частично использоваться в подсистемах.

---

**1.2. Размерности и константы**  
Фиксирует:

* канонические размеры всех уровней (8×8×2 Blocks, 8×8×8 Chunks, 2×2×2 Octochunks, 32³ vox);
* числовую раскладку (сколько чанков/окточанков/вокселей в Region, Block, Chunk);
* допустимое масштабирование Chunk/Octochunk;
* базовые страйды (VOXEL_SIZE, OCTO_SIZE, CHUNK_SIZE, BLOCK_SIZE, REGION_SIZE).

Это “паспорт размеров” и инварианты, на которых строится вся остальная математика.

---

**1.3. Каноническая система осей**  
Определяет:

* порядок осей `x | z | y`;
* принципы локальных диапазонов координат;
* запрет на отрицательные локальные координаты;
* знаковую модель октантов (A–I);
* зеркальную XZ-модель без signed-координат.

Этот блок отвечает за то, **как именно мы считаем “вперёд/назад/вверх/вниз”** без использования отрицательных индексов.

---

**1.4. Типы координат и мост между ними**  
Разделяет два слоя:

* **Тип A** — глобальные координаты мира (signed / float XYZ) для физики, движения, генерации.
* **Тип B** — локальные индексы топологии (Region/Block/Chunk/Octo/Voxel) ≥ 0 для хранения и адресации.

Описывает:

* как знак осей выносится в октант,
* почему контейнеры не хранят signed-координаты,
* как работает модель `Region + LocalFloat` — непрерывная позиция внутри Region + дискретная топология.

Этот блок — теоретическая основа для двусторонней связи **«векторный мир ↔ дискретная топология»**.

---

**1.5. Иерархические индексы и структура смещений**  
Формализует:

* набор индексов для всех уровней (rx/bx/cx/ox/vx и аналоги по Z/Y);
* канонические диапазоны индексов;
* правило `смещение = индекс * страйд`;
* связь индексов с плоскими индексами (flat index);
* иерархическое сложение смещений.

Это слой, который превращает “пространство контейнеров” в **строгую систему целочисленных индексов**.

---

**1.6. Формулы преобразований топологии**  
Задаёт точные формулы:

* **вниз**: от (Region/Block/Chunk/Octo/Voxel) к абсолютным локальным координатам внутри Region;
* **вверх**: от локальных координат внутри Region к иерархическим индексам.

Фиксирует свойства:

* биективность (1 адрес ↔ 1 точка),
* линейность и O(1),
* масштабируемость при изменении размеров чанка/окточанка.

Этот блок — чистая математика **encode/decode адресов**.

---

**1.7. Плоские индексы (Flat Indexing)**  
Показывает, как любые локальные координаты уровня (`x, z, y`) превратить в одно число `index`
для линейной памяти, и обратно:

* общая формула flat index;
* восстановление координат по индексу;
* конкретные примеры для Voxel, Octochunk, Chunk, Block.

Это фундамент для:

* массивов, буферов CPU/GPU,
* ECS-компонентов,
* сериализации,
* линейного обхода данных.

---

**1.8. Morton-порядок (Z-order)**  
Вводит альтернативную адресацию 3D → 1D через **побитовое перемежение** координат:

* идея Morton-кода (x/z/y битами);
* функции encode/decode (part_bits / compact_bits);
* ограничения (координаты ≥ 0, степени двойки, порядок осей);
* применение в SVO, LOD, spatial hashing, GPU-структурах.

Morton-индексы дополняют flat index и дают **иерархически-пространственный порядок** для деревьев и стриминга.

---

## 1.0.3. Как читать этот раздел

* Если нужно **понять структуру мира и размеры** — достаточно 1.1–1.2.  
* Если интересует **координатная система и переходы “мир ↔ индексы”** — 1.3–1.4.  
* Если нужна **конкретная математика encode/decode и индексы** — 1.5–1.6.  
* Если работаешь с **буферами, SVO, LOD, GPU** — 1.7–1.8.

Раздел 1.x можно воспринимать как **“математический паспорт пространства”**.
Все последующие части архитектуры (Routing / Rotation / DTO / HAOS / LOD / Streaming)
должны опираться на эти правила, а не вводить свои координатные схемы.

---

# **1.1. Уровни иерархии**

Ниже определён фиксированный набор логических контейнеров, формирующих структуру 3D-топологии.
Это строгое разбиение пространства, не зависящее от конкретных подсистем движка.

Каждый уровень описывает собственный масштаб и вложенность, но не предполагает обязательного использования в любой задаче.

### **1.1.1. Список уровней**

| Уровень       | Назначение (техническое определение)                     |
| ------------- | -------------------------------------------------------- |
| **Region**    | Корневой контейнер мира; базовый элемент макроструктуры. |
| **Block**     | Статический контейнер внутри Region.                     |
| **Chunk**     | Базовый контейнер плотных данных.                        |
| **Octochunk** | Структурный под-контейнер Chunk (его октант).            |
| **Voxel**     | Атомарная точка пространства.                            |

Все уровни являются **логически независимыми контейнерами** одной единой иерархии.

### **1.1.2. Свойства иерархии**

* Вложенность фиксирована и выглядит как:

```
Region → Block → Chunk → Octochunk → Voxel
```

* Каждый уровень:

  * имеет собственное пространство локальных координат,
  * определяет собственный размер,
  * задаёт собственный масштаб.

* Иерархия **всегда остаётся неизменной**,
  даже если размеры отдельных уровней (Chunk/Octochunk) масштабируются.

* Пропуск уровней возможен в подсистемах,
  но это **не нарушает топологию**, так как контейнеры остаются однозначными.

### **1.1.3. Логические роли уровней (внутритопологические)**

Эти роли отражают **внутренний смысл уровней только в рамках топологии**,
не описывая применение в подсистемах движка:

* **Region** — фундаментальное деление мира; минимальная независимая область пространства.
* **Block** — универсальный статический контейнер внутри Region.
* **Chunk** — основной носитель плотной структуры (детализация).
* **Octochunk** — неизменяемая структурная часть Chunk (один из восьми октантов).
* **Voxel** — минимальная пространственная единица.

---

# **1.2. Размерности и константы**

Этот раздел фиксирует канонические размеры всех уровней иерархии.
Размерности определяют масштаб, страйды и диапазоны локальных координат на каждом уровне.

Размеры подобраны так, чтобы:

* обеспечивать строгое разбиение пространства,
* гарантировать кратность уровней,
* поддерживать O(1) страйдинг,
* быть совместимыми с Morton/SVO-структурами,
* оставаться стабильными при масштабировании.

---

## 1.2.1. Канонические размеры уровней

Размеры указаны в единицах непосредственно нижнего уровня.

| Уровень       | Размерность      | Итог в вокселях                  |
| ------------- | ---------------- | -------------------------------- |
| **Region**    | 8×8×2 Blocks     | 4096×4096×1024 vox               |
| **Block**     | 8×8×8 Chunks     | 512×512×512 vox                  |
| **Chunk**     | 2×2×2 Octochunks | 64×64×64 vox                     |
| **Octochunk** | 32×32×32 vox     | 1/8 Chunk (структурный октант)   |
| **Voxel**     | 1×1×1            | —                                |

Эти величины являются каноном, на котором строится топология.

Комментарий о пропорции Region (8×8×2 Blocks)

Выбор вертикальной размерности Region в виде 8×8×2 Blocks (высота ≈ 1/3 от ширины) сделан сознательно.
Такое соотношение уменьшает объём пустых вертикальных слоёв, упрощает генерацию рельефа и снижает вычислительную глубину по оси Y.
Регион остаётся достаточно высоким для природного рельефа, но не превращается в избыточный куб 1×1×1, который увеличил бы стоимость генерации, SVO/LOD и вертикальной навигации.
Это решение оптимизирует плотность данных и делает вертикальные операции (высота, шум, SVO-ветвление, mesh-генерация) значительно эффективнее.


---

## **1.2.2. Иерархия в числах**

Для удобства восприятия:

### Region

* 8 × 8 × 2 Blocks = 128 Blocks
* 64 × 64 × 16 Chunks
* 128 × 128 × 32 Octochunks
* 4096 × 4096 × 1024 voxels

### Block

* 8 × 8 × 8 Chunks = 512 Chunks
* 512 × 512 × 512 vox
* 4096 Octochunks внутри блока

### Chunk

* 2 × 2 × 2 Octochunks = 8
* 64 × 64 × 64 vox

### Octochunk

* 32 × 32 × 32 vox

### Voxel

* 1 × 1 × 1

---

## **1.2.3. Гибкие уровни (масштабирование)**

Иерархия остаётся неизменной:

```
Region → Block → Chunk → Octochunk → Voxel
```

Но размеры **Chunk** и **Octochunk** могут масштабироваться:

### Примеры корректных масштабов:

* **Chunk = 32³ → Octochunk = 16³**
* **Chunk = 64³ → Octochunk = 32³ (канон)**
* **Chunk = 128³ → Octochunk = 64³**

### Нельзя изменять:

* размеры Block
* размеры Region
* глубину и структуру иерархии

### Почему изменение размеров не нарушает топологию:

* кратность слоёв сохраняется,
* страйды остаются целочисленными,
* адресация остаётся биективной,
* Morton и flat-index остаются корректными,
* все формулы масштабируются линейно.

---

## **1.2.4. Базовые страйды**

Для дальнейших разделов (формулы, индексация) фиксируются страйды:

| Страйд             | Величина |
| ------------------ | -------- |
| **VOXEL_SIZE**     | 1        |
| **OCTO_SIZE**      | 32       |
| **CHUNK_SIZE**     | 64       |
| **BLOCK_SIZE_XZ**  | 512      |
| **BLOCK_SIZE_Y**   | 512      |
| **REGION_SIZE_XZ** | 4096     |
| **REGION_SIZE_Y**  | 1024     |

Страйды определяют:

* диапазоны локальных координат,
* смещения при переходе между уровнями,
* формулы прямого/обратного преобразования.

---

## **1.2.5. Фиксированность структуры**

Все последующие уровни архитектуры (координаты, индексация, Morton, формулы)
основываются на следующих инвариантах:

* Region всегда состоит из 8×8×2 Blocks
* Block всегда состоит из 8×8×8 Chunks
* Chunk всегда состоит из 2×2×2 Octochunks
* Octochunk всегда состоит из куба вокселей
* Размер Octochunk определяет плотность Chunk
* Плотность Chunk может меняться, но вложенность остаётся прежней

---
Отлично. Делаю **1.3 максимально чистым, инженерным, без примеров, без маршрутов, без применения**, только фундамент топологии.

---

# **1.3. Каноническая система осей**

Этот раздел фиксирует базовую систему координат, используемую всей топологической моделью.
Система осей и порядок их следования определяют:

* структуру страйдов,
* формулы преобразований,
* диапазоны координат на уровнях,
* корректность индексации и Morton-кодирования.

---

## **1.3.1. Порядок осей**

Топология использует канонический порядок:

```
x | z | y
```

Где:

* **x** — поперечная ось (восток–запад)
* **z** — продольная ось (север–юг)
* **y** — вертикальная ось (верх–низ)

### Причины выбора именно этого порядка

* **X и Z образуют основную рабочую плоскость террейна** — большинство операций локализовано в 2D-разрезах.
* **Y вынесен последним**, что обеспечивает:

  * оптимальный страйдинг (flat index),
  * компактное представление слоёв,
  * совместимость с SVO-узлами,
  * упрощённую ротацию вокруг вертикальной оси.
* Порядок `x → z → y` соответствует структурам хранения данных в большинстве воксельных движков.

---

## 1.3.2. Локальные диапазоны координат

Каждый уровень топологии имеет собственный диапазон локальных координат, совпадающий с его размерностью.  
Локальные координаты всегда неотрицательны и служат основой для построения индексов.

Подробные числовые диапазоны по уровням приведены в разделе **1.5.2**.

---

## **1.3.3. Локальные координаты всегда неотрицательные**

Топология использует **только неотрицательные локальные координаты** на всех уровнях, включая Voxel, Octo, Chunk и Block.

Причины:

* упрощение адресации,
* корректная работа с flat index,
* отсутствие отрицательных значений при Morton-кодировании,
* однозначность преобразований вверх/вниз.

**Знаки осей хранятся отдельно, в структурной модели октантов.**

---

## **1.3.4. Центр региона и разрезы по осям**

Region разделяется на два слоя по вертикали:

* верхний слой (`ry ≥ 0` → октанты A–D),
* нижний слой (`ry < 0` → октанты E–I).

Центр региона определяется как:

```
x = 0
z = 0
y = середина между двумя блоками по вертикали
```

Это важно для:

* правильного распределения знаков,
* работы зеркальной XZ-модели,
* корректного формирования октантов.

---

## **1.3.5. Знаковая модель (октанты)**

Для кодирования направления без отрицательных локальных координат используется модель **8 октантов**.

Октанты определяются знаком компонент глобального смещения:

| Октант | sx | sz | sy |
| ------ | -- | -- | -- |
| A      | +  | +  | +  |
| B      | −  | +  | +  |
| C      | −  | −  | +  |
| D      | +  | −  | +  |
| E      | +  | +  | −  |
| F      | −  | +  | −  |
| G      | −  | −  | −  |
| I      | +  | −  | −  |

*(H пропускается намеренно — буква конфликтует с индексами и формулами.)*

### Основные свойства модели

* Октант кодирует **только знак направления (sx, sz, sy)**.
* Все уровни топологии используют **только абсолютные локальные значения**.
* Знак применяется **только на уровне Region** и влияет на глобальное позиционирование.
* Это обеспечивает полной отсутствие отрицательных значений в адресной модели.

---

## **1.3.6. Зеркальная модель XZ (без signed-координат)**

Для осей X и Z не используется отрицательная локальная координата.
Вместо этого:

```
X = расстояние от центральной вертикальной Z-плоскости
Z = расстояние от центральной вертикальной X-плоскости
```

А направление (лево/право, север/юг) задаётся через октант.

### Преимущества:

* безотказная сериализация,
* отсутствие отрицательных значений в логах/пакетах,
* компактное хранение,
* улучшенная совместимость с SVO и Morton.

---

# **1.4.1. Тип A — Глобальные координаты (signed XYZ)**

Глобальные координаты определяют позицию в **мировом пространстве** и используются:

* физикой,
* навигацией,
* генерацией,
* камерами,
* AI и движением,
* трассировкой лучей.

**Глобальные координаты могут быть отрицательными:**

```
X_abs ∈ ℤ
Z_abs ∈ ℤ
Y_abs ∈ ℤ
```

Это единственный слой системы, где отрицательные значения допустимы.

Глобальная система координат:

* бесконечна,
* непрерывна (в целых значениях),
* отражает реальное положение объектов в мире.

---

# **1.4.2. Тип B — Локальные координаты топологии (индексы ≥ 0)**

Топология (Region → Block → Chunk → Octochunk → Voxel) работает только с локальными координатами:

```
X_local ≥ 0
Z_local ≥ 0
Y_local ≥ 0
```

и индексами уровней:

```
bx, bz, by ≥ 0
cx, cz, cy ≥ 0
ox, oz, oy ≥ 0
vx, vz, vy ≥ 0
```

Это **индексы контейнера**, а не абсолютные мировые позиции.

Такое ограничение обеспечивает:

* корректность страйдов,
* детерминированность,
* отсутствие неоднозначностей,
* полную совместимость с SVO/Morton и GPU-вычислениями,
* компактные структуры данных.

---

# **1.4.3. Мост между глобальными и локальными координатами**

Чтобы связать signed XYZ с индексами топологии, используется двухступенчатая модель:

### **1) Направление (знак) — хранится в октанте**

Октант A–I определяет **sx, sz, sy** — знаки осей.

### **2) Расстояние — хранится в контейнере (индексы ≥ 0)**

Абсолютная величина координат разлагается на:

* индекс региона *(rx, rz, ry)*
* локальные координаты Region *(X_local, Z_local, Y_local)*
* индексы Block/Chunk/Octo/Voxel

То есть:

```
signed XYZ → (octant signs) + (abs → region indices → local indices)
```

Это позволяет полностью восстановить абсолютную координату из топологической.

---

# **1.4.4. Region как граница между двумя пространствами**

Region играет роль «моста» между:

* глобальным signed-миром
* и локальными неотрицательными координатами

**Вертикальная сторона (верх/низ)** определяется только значением `ry`:

```
ry ≥ 0 → верхняя полупространство мира
ry < 0 → нижняя полупространство мира
```

При этом **локальная координата Y_local всегда ≥ 0**.

Именно сочетание:

```
ry (слой мира)
+
sy (знак направления по Y)
```

определяет абсолютное положение точки по вертикали.

---

# **1.4.5. Абсолютная координата не хранится внутри контейнера**

Важно понимать:

> **Ни один уровень топологии не хранит signed координату.
> Он хранит только индексы.**

Абсолютная позиция восстанавливается через:

```
abs_value = (region_index * stride) + local_index
signed_value = sign_from_octant * abs_value
```

Это ключевой принцип архитектуры.

---

# **1.4.6. Итоговая модель**

Каждая точка в мире описывается двумя слоями:

### ✔ Мировой слой (signed XYZ)

Для физики, генерации, движения.

### ✔ Топологический слой (индексы ≥ 0)

Для хранения, поиска, сериализации, SVO, LOD.

Связь обеспечивается структурой:

```
octant   → знаки осей  
region   → крупные смещения  
indices  → позиция внутри контейнера  
```

---

# **1.4.7. Почему архитектура разделяет эти координаты**

* снижает количество ошибок
* повышает читаемость и детерминированность
* упрощает линейную иерархию преобразований
* устраняет отрицательные значения в индексах
* делает топологию совместимой с GPU и SVO
* позволяет адресовать мир до миллиардов единиц
* уменьшает объём данных для сети и сериализации

---

# **1.4.8. Плавающие координаты внутри Region (опционально)**

В прикладных подсистемах (физика, навигация, движение, камеры) удобно использовать
не только дискретные индексы, но и непрерывные (float) координаты внутри Region.

Для этого вводится модель:

```

RegionPos = Region + LocalFloat

```

Где:

* `Region` — целочисленные индексы региона в мире:
```

(rx, rz, ry)

```
* `LocalFloat` — локальная позиция внутри Region в вещественных координатах:
```

(x_f, z_f, y_f)

```

При этом выполняются ограничения:

* `x_f, z_f ∈ [0 .. REGION_SIZE_XZ)`
* `y_f ∈ [0 .. REGION_SIZE_Y)`

То есть Region задаёт «какой это регион мира»,  
а `LocalFloat` — непрерывную позицию внутри его объёма.

---

## 1.4.8.1. Связь с глобальными координатами

Пусть есть глобальная позиция объекта в мире в виде вещественного вектора:

```

X_abs_f, Z_abs_f, Y_abs_f ∈ ℝ

```

Тогда индексы Region и локальные координаты внутри него вычисляются так:

```

rx = floor(X_abs_f / REGION_SIZE_XZ)
rz = floor(Z_abs_f / REGION_SIZE_XZ)
ry = floor(Y_abs_f / REGION_SIZE_Y)

x_f = X_abs_f - rx * REGION_SIZE_XZ
z_f = Z_abs_f - rz * REGION_SIZE_XZ
y_f = Y_abs_f - ry * REGION_SIZE_Y

```

* `(rx, rz, ry)` определяют, в какой Region попадает точка.
* `(x_f, z_f, y_f)` задают непрерывную позицию внутри этого Region.

Так формируется «мост» между глобальным float-пространством и дискретной структурой Region.

---

## 1.4.8.2. Связь с топологическими индексами

Из `LocalFloat` можно в любой момент восстановить иерархические индексы:

* индексы вокселя:
```

vx = floor(x_f / VOXEL_SIZE)
vz = floor(z_f / VOXEL_SIZE)
vy = floor(y_f / VOXEL_SIZE)

```
* индексы Octochunk / Chunk / Block вычисляются аналогично
через целочисленное деление и остаток (см. формулы 1.6.3).

То есть:

* дробная часть `LocalFloat` используется физикой/движением,
* целая часть `floor(LocalFloat / stride)` — 
даёт топологические индексы для вокселей и контейнеров.

Важно:

* модель Region + LocalFloat **не меняет** топологию,
* она лишь вводит удобный прикладной слой над уже существующими формулами (1.5, 1.6),
* все прямые/обратные преобразования координат остаются корректными.

---

## 1.4.8.3. Практический смысл модели

Модель `Region + LocalFloat` позволяет:

* использовать непрерывные float-позиции для:
* физики,
* навигации,
* камер,
* анимаций,
* и одновременно иметь:
* строгое топологическое разложение в Region/Block/Chunk/Octo/Voxel,
* детерминированную адресацию,
* совместимость с SVO/LOD, flat-index и Morton.

Таким образом:

* мировой слой (signed/float XYZ)
* и топологический слой (индексы ≥ 0)

связываются через простую и обратимую модель Region + LocalFloat,
которая сохраняет все свойства топологии и при этом даёт свободное плавное движение внутри Region.

---

# **1.5. Иерархические индексы и структура смещений**

Иерархические индексы — это числовые координаты внутри каждого уровня топологии.
Они обеспечивают детерминированное разложение пространства на контейнеры,
формируют структуру плоских массивов и служат основой для прямых и обратных преобразований координат.

Все индексы являются **целыми, неотрицательными**, и определяются размерностями уровней.

---

## **1.5.1. Индексы уровней (общая модель)**

Каждый уровень иерархии задаёт собственное пространство индексов:

| Уровень       | Индексы                                  |
| ------------- | ---------------------------------------- |
| **Region**    | `(rx, rz, ry)` — индексы регионов в мире |
| **Block**     | `(bx, bz, by)` — индексы блоков в Region |
| **Chunk**     | `(cx, cz, cy)` — индексы чанков в Block  |
| **Octochunk** | `(ox, oz, oy)` — индексы октантов Chunk  |
| **Voxel**     | `(vx, vz, vy)` — индексы вокселя         |

Все уровни используют:

```
индекс → диапазон [0..N-1]
```

где N определяется размерностью уровня (см. 1.2).

Это гарантирует:

* O(1) преобразования,
* отсутствие отрицательных значений,
* строгую биективность адресации,
* совместимость с flat-index и Morton.

---

## 1.5.2. Диапазоны индексов

Диапазоны индексов совпадают с размерностью каждого уровня (в канонической конфигурации 64³/32³):

| Уровень       | Диапазон индексов                         |
| ------------- | ------------------------------------------ |
| **Voxel**     | `vx, vz, vy ∈ [0..31]`                    |
| **Octochunk** | `ox, oz, oy ∈ [0..1]`                     |
| **Chunk**     | `cx, cz, cy ∈ [0..7]`                     |
| **Block**     | `bx, bz ∈ [0..7]`, `by ∈ [0..1]`          |
| **Region**    | `X_local, Z_local ∈ [0..4095]`, `Y_local ∈ [0..1023]` |

Вертикальные и горизонтальные диапазоны строго определяются страйдами (см. 1.2.4) и автоматически масштабируются при изменении размеров Chunk/Octochunk.

Диапазоны выше задают **полный канонический адрес** для каждого уровня топологии.
Это означает:

* для каждого уровня существует строгий диапазон индексов `[0..N-1]`,
* при любом варианте использования (включая обходы, генерацию, сериализацию)
  все внутренние операции опираются именно на эти диапазоны.

### Примечание о гибкости и пропуске уровней

В подсистемах (Routing, LOD, DTO/HAOS и т.д.) разрешено:

* использовать **не всю** цепочку уровней,
* формировать маршруты вида:
  * `Region → Voxel`,
  * `Region → Chunk`,
  * `Block → Voxel` и т.п.

При этом:

* канонические диапазоны индексов **не меняются**,
* «пропущенные» уровни считаются **неявно равными нулю**  
  (например, если маршрут не содержит Chunk/Octochunk, то `cx=cz=cy=0` и `ox=oz=oy=0` в полном адресе),
* строковый/структурный формат маршрута будет описан отдельно в разделе **Routing**,
  но всегда сводится к этому полному набору индексов.

Топология фиксирует:

* какие индексы возможны,
* как они разлагаются по страйдам,
* как из них собирается абсолютная координата.

А раздел Routing позже задаст, **какие комбинации уровней можно указывать явно**,  
и как сокращённый маршрут (например, `Region + Octant + v(x|z|y)`) приводится к полному адресу
через те же диапазоны и страйды.

---

## **1.5.3. Правило «индекс → страйд → смещение»**

Каждый уровень определяет **страйд** — число вокселей, приходящееся на единицу индекса этого уровня.

Принцип:

```
смещение уровня = индекс * страйд уровня
```

Например:

```
смещение чанка = cx * CHUNK_SIZE
смещение блока = bx * BLOCK_SIZE_XZ
смещение региона = rx * REGION_SIZE_XZ
```

Это правило — фундамент прямых (вниз) и обратных (вверх) преобразований.

---

## **1.5.4. Плоские индексы (flat index)**

Плоский индекс — это преобразование тройки индексов в одно число:

```
index = x + size_x * (z + size_z * y)
```

Где:

* `x, z, y` — локальные индексы уровня,
* `size_x, size_z` — размерности уровня.

Плоский индекс используется:

* в памяти CPU/GPU,
* при хранении SVO-узлов,
* в SSBO/UBO buffers,
* при сериализации данных,
* в ECS-компонентах.

Характеристики:

* всегда O(1),
* полностью обратим,
* независим от signed-направлений,
* детерминирован.

---

## **1.5.5. Обратимость индексирования**

Для любого плоского индекса существует обратная операция:

```
x = index % size_x
t = index / size_x
z = t % size_z
y = t / size_z
```

Это обеспечивает:

* восстановление структур топологии из линейной памяти,
* прямую работу с GPU-данными,
* совместимость с Morton-кодом,
* строгость структуры данных.

---

## **1.5.6. Иерархическое наследование индексов**

Адрес точки в мире может быть представлен как последовательность структурных индексов:

```
Region → Block → Chunk → Octochunk → Voxel
```

Каждый уровень добавляет собственный вклад в абсолютное смещение:

```
смещение уровня Region
+ смещение уровня Block
+ смещение уровня Chunk
+ смещение уровня Octochunk
+ локальный индекс Voxel
```

Это формирует строгую иерархию смещений:

```
offset = 
    rx * REGION_SIZE_XZ
  + bx * BLOCK_SIZE_XZ
  + cx * CHUNK_SIZE
  + ox * OCTO_SIZE
  + vx
```

(аналогично для Z и Y)

Иерархическое сложение смещений — основа для прямых формул в разделе 1.6.

---

## **1.5.7. Роль индексов в адресации и симметрии**

Иерархические индексы обеспечивают:

* биективность адреса,
* корректность обратных преобразований,
* независимость от signed XYZ,
* отсутствие отрицательных смещений,
* строгую структуру для всех подсистем:

  * генерация,
  * LOD,
  * SVO,
  * симуляции,
  * редактирование,
  * статические и динамические буферы.

---

---

# **1.6. Формулы преобразований топологии**

Этот раздел определяет строгие математические правила преобразования между:

* иерархическими уровнями топологии
* и абсолютными координатами в локальном пространстве Region

Формулы основаны на страйдах (см. 1.2.4) и иерархических индексах (см. 1.5).

Все преобразования:

* детерминированы,
* линейны,
* O(1),
* полностью обратимы,
* независимы от применения топологии в подсистемах.

---

# **1.6.1. Линейные смещения и страйды**

Каждый уровень определяет **индекс** и **страйд**, задающий длину стороны контейнера в вокселях.

Общее правило:

```
смещение уровня = индекс уровня * страйд уровня
```

Для канон. конфигурации:

| Уровень   | Индекс         | Страйд по X / Z / Y (vox) |
|-----------|----------------|----------------------------|
| Region    | rx, rz, ry     | 4096 / 4096 / 1024         |
| Block     | bx, bz, by     | 512  / 512  / 512          |
| Chunk     | cx, cz, cy     | 64   / 64   / 64           |
| Octochunk | ox, oz, oy     | 32   / 32   / 32           |
| Voxel     | vx, vz, vy     | 1    / 1    / 1            |

Абсолютная локальная координата внутри Region получается сложением смещений всех уровней.

---

# **1.6.2. Прямое преобразование (вниз)**

### *Иерархия → абсолютные локальные координаты Region*

Пусть дана структура индексов:

```
Region:    (rx, rz, ry)
Block:     (bx, bz, by)
Chunk:     (cx, cz, cy)
Octochunk: (ox, oz, oy)
Voxel:     (vx, vz, vy)
```

Тогда абсолютные локальные координаты внутри Region вычисляются как:

```
X_local =
    rx * REGION_SIZE_XZ +
    bx * BLOCK_SIZE_XZ +
    cx * CHUNK_SIZE   +
    ox * OCTO_SIZE    +
    vx

Z_local =
    rz * REGION_SIZE_XZ +
    bz * BLOCK_SIZE_XZ +
    cz * CHUNK_SIZE   +
    oz * OCTO_SIZE    +
    vz

Y_local =
    ry * REGION_SIZE_Y +
    by * BLOCK_SIZE_Y +
    cy * CHUNK_SIZE   +
    oy * OCTO_SIZE    +
    vy
```

Свойства:

* каждая координата — сумма пяти независимых смещений,
* формулы полностью линейны,
* каждый уровень вносит вклад, равный его страйду.

### Важное уточнение

Это **локальные абсолютные координаты Region**, не мировые.
Они не содержат знаков и относятся только к контейнеру Region.

---

# **1.6.3. Обратное преобразование (вверх)**

### *Абсолютные локальные координаты Region → иерархические индексы*

Дано:

```
X_local, Z_local, Y_local
```

Требуется восстановить:

```
rx, rz, ry
bx, bz, by
cx, cz, cy
ox, oz, oy
vx, vz, vy
```

Общее правило:

```
index = value // SIZE
value = value % SIZE
```

Порядок разложения сверху вниз:

---

### **1) Region**

```
rx = X_local // REGION_SIZE_XZ
rz = Z_local // REGION_SIZE_XZ
ry = Y_local // REGION_SIZE_Y

X1 = X_local % REGION_SIZE_XZ
Z1 = Z_local % REGION_SIZE_XZ
Y1 = Y_local % REGION_SIZE_Y
```

---

### **2) Block**

```
bx = X1 // BLOCK_SIZE_XZ
bz = Z1 // BLOCK_SIZE_XZ
by = Y1 // BLOCK_SIZE_Y

X2 = X1 % BLOCK_SIZE_XZ
Z2 = Z1 % BLOCK_SIZE_XZ
Y2 = Y1 % BLOCK_SIZE_Y
```

---

### **3) Chunk**

```
cx = X2 // CHUNK_SIZE
cz = Z2 // CHUNK_SIZE
cy = Y2 // CHUNK_SIZE

X3 = X2 % CHUNK_SIZE
Z3 = Z2 % CHUNK_SIZE
Y3 = Y2 % CHUNK_SIZE
```

---

### **4) Octochunk**

```
ox = X3 // OCTO_SIZE
oz = Z3 // OCTO_SIZE
oy = Y3 // OCTO_SIZE

X4 = X3 % OCTO_SIZE
Z4 = Z3 % OCTO_SIZE
Y4 = Y3 % OCTO_SIZE
```

---

### **5) Voxel**

```
vx = X4
vz = Z4
vy = Y4
```

---

# **1.6.4. Свойства прямых и обратных преобразований**

### ✔ **1. Биективность**

Каждый набор индексов соответствует ровно одной координате внутри Region.

### ✔ **2. Обратимость**

Для любых значений выполняется:

```
to_indices(to_local_absolute(p)) = p
```

### ✔ **3. Линейность**

Все формулы:

* без ветвлений,
* без условий,
* без signed-операций,
* полностью O(1).

### ✔ **4. Масштабируемость**

Если размеры Chunk/Octochunk изменены,
формулы остаются идентичными —
меняются только страйды.

### ✔ **5. Независимость уровней**

Каждый уровень влияет на координаты только через собственный страйд.
Это обеспечивает стабильность при пропуске уровней в подсистемах.

---

# **1.6.5. Итог**

Раздел 1.6 сформировал математическую базу адресации:

* строгие линейные формулы,
* полную обратимость,
* независимость от знаковой модели,
* масштабируемость,
* совместимость со всеми подсистемами (LOD, SVO, рендеринг, DTO/HAOS).

Теперь топология готова к добавлению следующих фундаментальных слоёв:
плоских индексов, Morton-кода и ротаций (в следующих разделах документа).

---

# **1.7. Плоские индексы (Flat Indexing)**

Плоский индекс — это отображение тройки координат уровня
в одно целое число, представляющее позицию элемента в линейном массиве.

Flat index обеспечивает:

* строгое O(1) преобразование между 3D-координатами и линейной памятью,
* детерминированную структуру хранения,
* совместимость с CPU/GPU-буферами,
* прямую работу с массивами, таблицами, SVO/LOD-узлами.

Flat index — фундаментальный элемент топологии,
так как он создаёт единый интерфейс между 3D-моделью и линейным расположением данных.

Это расширенный разбор flat index, уже введённого в 1.5”.

---

# **1.7.1. Модель линейной памяти**

Любой контейнер топологии
(**Octochunk**, **Chunk**, **Block**, **Region**)
может быть представлен как линейный участок памяти.

Это означает, что трёхмерная структура уровня раскладывается в последовательный 1D-массив длиной:

```
len = size_x * size_z * size_y
```

где:

* `size_x`, `size_z`, `size_y` — канонические размеры уровня.

### **Зачем нужна модель линейной памяти**

* Обеспечивает **унифицированное хранение** контейнеров на CPU и GPU.
* Позволяет использовать **одну формулу индексации (flat index)** для всех уровней.
* Делает структуру полностью совместимой с:

  * массивами,
  * SSBO/UBO буферами,
  * ECS-архитектурой,
  * сериализацией,
  * SVO/LOD-структурами.
* Обеспечивает **O(1)** доступ к любому элементу уровня.
* Устраняет необходимость в многомерных массивах и сложных addressing-схемах.

### **Ключевые свойства модели**

* **Строгое отображение 3D → 1D** без потери информации.
* **Полная обратимость 1D → 3D** через обратный flat index.
* **Отсутствие отрицательных координат** (гарантируется топологией).
* **Последовательность данных** формирует:

  * высокую кэш-локальность,
  * предсказуемый обход,
  * эффективную работу генераторов, физики и рендера.
* Модель **масштабируется линейно** — подходит как для 32³, так и для 128³ или 256³ чанков.

---

# **1.7.2. Формула преобразования (x, z, y → index)**

Топология использует канонический порядок осей:

```
x | z | y
```

Это означает:

* X — быстрый шаг (идёт первым),
* Z — средний шаг,
* Y — самый медленный шаг (слой).

Формула:

```
flat_index =
    x +
    size_x * (
        z +
        size_z * y
    )
```

Где:

* `x, z, y` — локальные координаты уровня,
* `size_x, size_z, size_y` — размерности уровня.

Свойства формулы:

* полностью линейна,
* не требует ветвлений,
* использует только целочисленную арифметику,
* одинаково работает для всех уровней.

---

# **1.7.3. Обратное преобразование (index → x, z, y)**

Для восстановления 3D-координаты из плоского индекса используется:

```
x = index % size_x
t = index / size_x

z = t % size_z
y = t / size_z
```

Гарантии:

* полная обратимость,
* отсутствие потери информации,
* O(1) вычисление,
* строгая соответствие тройки (x, z, y) исходному элементу массива.

---

# **1.7.4. Flat index для каждого уровня**

Ниже указано, как формируется индекс для канонических размеров уровней.

### **Voxel (внутри Octochunk, 32×32×32)**

```
voxel_index =
    vx +
    32 * (
        vz +
        32 * vy
    )
```

### **Octochunk (внутри Chunk, 2×2×2)**

```
octo_index =
    ox +
    2 * (
        oz +
        2 * oy
    )
```

### **Chunk (внутри Block, 8×8×8)**

```
chunk_index =
    cx +
    8 * (
        cz +
        8 * cy
    )
```

### **Block (внутри Region, 8×8×2)**

```
block_index =
    bx +
    8 * (
        bz +
        8 * by
    )
```

### Примечание

Размерности автоматически меняются,
если Chunk/Octochunk масштабируются (см. 1.2.3),
но формулы остаются неизменными.

---

# **1.7.5. Связь flat index и иерархических уровней**

Flat index работает в замкнутом объёме одного уровня.

Иерархическая адресация уровня выше (1.6):

```
offset = Σ (index_level * stride_level)
```

Flat index работает внутри уровня:

```
local_offset = flat_index(x, z, y)
```

Совместно эти механизмы обеспечивают:

* структурный разбор,
* линейную компоновку,
* однозначность адресации,
* совместимость со всеми алгоритмами хранения.

---

# **1.7.6. Инварианты и ограничения**

* flat index использует только **неотрицательные** координаты,
* формулы обратимы для любого уровня,
* Y всегда последняя ось,
* линейная память всегда размером `size_x * size_z * size_y`,
* порядок осей неизменен для всех уровней,
* GPU/CPU-буферы могут напрямую оперировать индексами,
* переупорядочивание осей *нарушает* совместимость с топологией.

---

# **1.8. Morton-порядок (Z-order)**

*Фундаментальная компактная адресация для иерархических структур*

Morton-порядок — это способ кодирования трёхмерных координат
в одномерный индекс путём **побитового перемежения** координат x, z, y:

```
x0 z0 y0 x1 z1 y1 x2 z2 y2 ...
```

Такой порядок:

* сохраняет пространственную локальность,
* идеально подходит для SVO/LOD,
* улучшает кеширование,
* даёт компактное дерево пространственных узлов,
* полностью совместим с системой координат `x | z | y`.

Morton-код выступает как альтернативный к flat index (см. 1.7) способ отображения 3D → 1D, оптимизированный не под последовательное сканирование памяти, а под пространственную локальность и иерархические деревья (SVO/LOD).
---

# **1.8.1. Основная идея Morton-кода**

Пусть есть локальная координата уровня:

```
(x, z, y)
```

Тогда Morton-код — это число, в котором:

* биты X занимают позиции `0, 3, 6, 9, ...`
* биты Z — позиции `1, 4, 7, 10, ...`
* биты Y — позиции `2, 5, 8, 11, ...`

То есть:

```
bitstream = interleave_bits(x, z, y)
```

Где каждая тройка бит задаёт положение в одном из 8 подблоков (2×2×2) на соответствующем уровне разбиения контейнера.

### Свойства

* Полностью **обратим**.
* Работает только с **неотрицательными** координатами (что совпадает с топологией).
* Поддерживает любые размеры Octochunk/Chunk, кратные степени двойки.
* Совместим со всеми уровнями — voxel, octo, chunk, block, region.

Это делает его идеальным фундаментальным форматом пространственного хранения.

---

# **1.8.2. Morton-encode (3D → 1D)**

Нормализуем координаты уровня:
```
x, z, y ∈ [0..N)
```

где N не превышает размерности уровня по соответствующей оси  
и укладывается в разрядность целевого целого типа (например, u16/u32).


Перемежаем биты:

```
morton = part_bits(x) | (part_bits(z) << 1) | (part_bits(y) << 2)
```

Где `part_bits` — функция, которая раздвигает биты числа:

```rust
fn part_bits(mut x: u32) -> u32 {
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;
    x
}
```

### Свойства encode

* O(1) побитовая операция,
* подходит для CPU и GPU,
* использует абсолютные локальные координаты уровня,
* не зависит от масштаба Chunk/Octochunk.

---

# **1.8.3. Morton-decode (1D → 3D)**

Для обратного преобразования используется операция `compact_bits`,
которая извлекает каждый третий бит в отдельное число.

Алгоритмически:

```
x = compact_bits(morton >> 0)
z = compact_bits(morton >> 1)
y = compact_bits(morton >> 2)
```

Где `compact_bits` — полная инверсия `part_bits`.

### Свойства decode

* строго восстанавливает исходные координаты,
* сохраняет диапазон значений,
* гарантирует детерминированность.

---

# **1.8.4. Где используется Morton-порядок в топологии**

Morton-порядок является **ключевым базовым механизмом** для:

### ✔ SVO (Sparse Voxel Octree)

Каждый узел SVO использует Morton-код для:

* идентификации потомков,
* выбора октанта,
* компактного хранения.

### ✔ LOD-иерархий

Morton код позволяет:

* сортировать чанки по пространству,
* объединять данные в блоки,
* эффективно выстраивать упорядоченные деревья.

### ✔ Spatial hashing

Используется как:

* ключ хеш-таблиц,
* компактный индекс узлов,
* структурированный идентификатор мешей/вокселей.

### ✔ GPU-структур (SSBO/UBO)

Morton-индексы формируют:

* предсказуемые последовательности обращения,
* компактные таблицы соседей,
* локализованный доступ к 3D-данным.

---

# **1.8.5. Ограничения и инварианты Morton-порядка**

Morton-порядок корректен только при следующих условиях:

* координаты ≥ 0 (совместимо с топологией),
* размеры контейнеров — степени двойки,
* порядок осей — строго `x | z | y`.

### Полностью совместим:

* с локальными координатами внутри Region (см. 1.3).
* со страйдами (1.6),
* с плоской индексацией (1.7),
* с масштабированием Chunk/Octochunk (1.2.3).

---

# **1.8.6. Итог секции Morton**

Morton-порядок даёт:

* пространственную локальность,
* компактность,
* SVO-совместимость,
* ускоренные GPU-операции,
* однозначность адресации,
* строгое 3D-дерево для всех уровней топологии.

Он является фундаментальной основой для будущих блоков:

* SVO/LOD,
* топологического роутинга,
* динамики,
* стриминга.

---