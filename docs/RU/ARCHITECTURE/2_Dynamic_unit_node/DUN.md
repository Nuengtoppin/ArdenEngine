
---

# 0. Обзор / mini-README

Этот раздел вводит фундаментальную сущность **DUN (Dynamic Unit Node)** —  
первую динамическую единицу мира, построенную поверх  
**Topology → Routing → Rotation** (1_TopologyLogic_Route_Rotation) сокращенно (1.х)

DUN связывает:

- строгую статичную топологию мира,
- адресацию Route,
- runtime-позицию и ориентацию (float + quaternion),
- локальную геометрию (воксели, SVO, меши),
- состояния активности (ACTIVE / DORMANT / ARCHIVED).

Документ фиксирует **базовые инварианты** DUN и правила, которые позволят:

- вращать контейнеры на 360°, не ломая топологию,
- хранить локальную воксельную структуру безопасно,
- строить физику и рендер на поверхности,
- правильно связать Route и float-пространство.

Раздел **не описывает** EQ, HAOS, DTO или игровой цикл —  
этим будут посвящены документы 3.x (EQ / Simulation Layer).

---

### 0.1. Стратегия документа

Раздел 2.x создаёт **мост между статичным миром (1.x)** и будущими динамическими подсистемами (3.x).

На первом этапе задача документа:

1) Чётко определить, что такое DUN  
2) Зафиксировать инварианты (что он делает и чего не делает)  
3) Определить Static vs Dynamic DUN  
4) Описать модель якорения:  
   **Topology → Route → Float → Transform**  
5) Объяснить, что вращается, а что остаётся статичным  
6) Определить, где живут воксели и где живут меши  
7) Обозначить место DUN в общем порядке архитектуры

В этом документе **нет логики симуляции, сна, пробуждения или сетевого стриминга** —  
это придёт позже в EQ-Core, EQ-Sim и HAOS.

---

# 1. Назначение и роль DUN

## 1.1. Определение

**DUN (Dynamic Unit Node)** — это атомарный узел динамического мира, который объединяет:

- привязку к топологии (**Route → дискретный адрес**),
- runtime-трансформацию (**позиция + quaternion**),
- локальную геометрию (**воксели → mesh / SVO**),
- базовое состояние активности (ACTIVE / DORMANT / ARCHIVED).

DUN — это **не контейнер топологии**, а надстройка над ней.  
Он существует в динамическом пространстве, но опирается на строгие правила триады (1.х)
Он НЕ изменяет ни размеры контейнеров, 
ни страйды, ни маршрутизацию, ни ротацию в топологии.

DUN вводит только динамику: transform, float, mesh, collider, состояния.

## 1.2. Static DUN vs Dynamic DUN
DUN поддерживает два эксплуатационных режима: **Static** и **Dynamic**.  
Оба режима используют одну и ту же внутреннюю структуру,  
но отличаются поведением transform, ротацией, участием в симуляции и правилами хранения.

---

### **Static DUN (режим статического узла)**

Static DUN — это DUN, который представляет **неподвижный участок мира**,  
логически равный топологическому контейнеру (Chunk / Subchunk / Octochunk).

Static DUN служит **динамической оболочкой вокруг статической топологии**.  
Он НЕ перемещается и НЕ вращается плавно, но имеет минимальную динамику (state, mesh rebuild),  
и полностью синхронизирован с триадой Topology → Routing → Rotation.

## 1.3. Область ответственности DUN

Важно отделять то, **чем DUN является**, от того, **что он делает**.

DUN описывает:

- привязку к топологии (Route),
- своё положение и ориентацию (Transform),
- локальный объём (DunVolume),
- поверхность и коллайдеры (DunSurface),
- ограничивающие объёмы (DunBounds),
- текущее состояние участия в мире (DunState).

При этом DUN **не**:

- тикает сам себя и не содержит логики игрового цикла;
- не решает, когда быть Active / Dormant / Archived;
- не управляет логированием, профайлингом или стримингом;
- не знает о DTO, HAOS или EQ-алгоритмах.

Эти задачи лежат на подсистемах:

- **EQ-Core / EQ-Sim** — хранение, тик, симуляция;
- **HAOS / DTO** — оптимизация, сон/пробуждение, архивирование.

DUN остаётся **прозрачным узлом данных и привязки**, поверх которого уже работают системы симуляции и оптимизаций.

---

#### **1. Static-Transform**

```

position: фиксирована topological_origin(Route)
rotation: дискретная (0/90/180/270°)
scale: 1.0

```

Static DUN получает позицию только из Route → decode(Route)  
и не имеет собственных float-смещений.

Ротация возможна только через Rotation Layer (дискретно),  
без quaternion и без непрерывных углов.

---

#### **2. Static-Geometry**

```

voxel_grid: доступен всегда
svo_tree: опционально (для LOD)
mesh[]: генерируется, но не вращается dynamic-transform'ом
aabb_local: постоянный
obb_world: совпадает с AABB

```

Static DUN никогда не имеет OBB под углом.  
Он всегда axis-aligned.

---

#### **3. Static-Simulation Role**
```

simulate_physics: false (кроме внутренних проверок)
dynamic_move: false
dynamic_rotate: false
tick_rate: минимальный (зависит от HAOS/DTO)

```

Static DUN участвует в симуляции как:
- носитель вокселей,
- источник мешей,
- участник стриминга мира,
- объект, который может “засыпать/просыпаться”.

Он НЕ участвует в физике как тело.

---

#### **4. Static-State Rules**
```

ACTIVE:   когда обновляется меш, генерация, загрузка
DORMANT:  основное состояние (почти всегда)
ARCHIVED: может быть выгружен частично/полностью
TEMP:     при стриминге чанков

```

---

#### **5. Static Invariants**
1. Static DUN **никогда не двигается** в float-пространстве.  
2. Rotation только через **Rotation Layer (дискретно)**.  
3. Контейнер полностью соответствует топологическому размеру.  
4. Collider Static DUN — это **axis-aligned mesh collider**.  
5. Static DUN — основа **всего мира**, но не субъект движения.

---

### **Dynamic DUN (режим динамического узла)**

Dynamic DUN — это DUN, который является **подвижным физическим объектом**:  
модулем, кораблём, платформой, элементом конструкции, техникой, NPC-структурой —  
всем, что должно:

- двигаться,
- плавно вращаться,
- участвовать в физике,
- иметь локальную воксельную структуру,  
- иметь собственный transform и поведение.

Dynamic DUN — это **мир внутри мира** (mini-world, мини-топология).

---

#### **1. Dynamic-Transform**
```

position: Vec3 (плавное движение)
rotation: Quat (плавное вращение)
scale: Vec3 (обычно 1.0)

```

Именно Dynamic DUN получает:

- полноценную float-позицию,
- quaternion,
- мировую OBB,
- динамическое тело физики.

---

#### **2. Dynamic-Geometry**
```

voxel_grid / svo_tree: локальная топология
mesh[]: вращается и двигается вместе с transform
aabb_local: axis-aligned в локальном пространстве DUN
obb_world: полный Oriented Bounding Box

```

Тут ключевое отличие:

- **воксельная сетка НЕ вращается** (инвариант),
- **меш вращается полностью** (surface representation).

Это обеспечивает:
- стабильность страйдов,
- чистоту индексации,
- корректную физику.

---

#### **3. Dynamic-Simulation Role**
```

simulate_physics: true
dynamic_move: true
dynamic_rotate: true
tick_rate: зависит от EQ-Sim

```

Dynamic DUN участвует в симуляции как:

- физический объект,
- источник перемещающейся поверхности,
- контейнер для динамической геометрии,
- участник бустов/LOD/SVO внутри HAOS.

---

#### **4. Dynamic-State Rules**
```

ACTIVE:   в движении, в физике, под тиком
DORMANT:  спит, если объект неподвижен долго
ARCHIVED: может быть упакован в blueprint/snapshot
TEMP:     при появлении в мире

```

---

#### **5. Dynamic Invariants**
1. Dynamic DUN может иметь **любую позицию** в мировых float-координатах.  
2. Rotation — **не ограничена** дискретной сеткой (используется quaternion).  
3. Воксели остаются осевыми, mesh — вращается.  
4. Dynamic DUN **имеет физическое тело (rigidbody)**.  
5. Dynamic DUN может перемежать топологические зоны (пересекать границы чанков).  
6. Route остаётся логическим якорем, но transform — runtime-источник истины.

---

#### **6. Отличия Static vs Dynamic DUN — инженерная сводка**

| Свойство | Static DUN | Dynamic DUN |
|---------|-------------|--------------|
| Позиция | От Route (фикс) | Float (Vec3), свободная |
| Ротация | Дискретная 0/90/180/270 | Quaternion 0–360° |
| Collider | Axis-aligned | Oriented (rotate with object) |
| Воксели | Постоянны | Постоянны |
| Mesh | Не вращается | Вращается |
| Физика | Нет тела | Есть тело |
| Tick | Почти не тикнет | Полный тик |
| Использование | Мир | Подвижные объекты |
| AABB | = OBB | ≠ OBB |
| Состояния | ACTIVE/DORM/ARCH | ACTIVE/DORM/ARCH |

---

### **Почему оба режима — часть одного DUN**

Static и Dynamic — это **режимы эксплуатации**, а не два разных типа сущности.

Они используют:

- одинаковую структуру хранения,  
- одинаковые инварианты топологии,  
- одинаковый anchor-механизм (Route → Float → Transform),  
- одинаковый AABB/mesh-пайплайн,  
- одинаковую связь с EQ-Core/Sim.

Различия только в поведении transform.

Это позволяет:

- иметь единый формат данных,  
- единый pipeline генерации мешей,  
- единый механизм сна/пробуждения,  
- единый интерфейс для рендера, физики и стриминга.

---

# 2. Инварианты DUN 

Чтобы DUN не ломал логику пространства, вводятся жёсткие инварианты.  
Они задают, что DUN имеет право делать, а чего делать не может.

---

## 2.1. DUN не изменяет топологию

DUN:

- не меняет страйды уровней (Region/Block/Chunk/Octo и т.п.);
- не меняет размеры контейнеров;
- не нарушает формулы адресации (encode/decode Route).

Топология мира, описанная в документах 1.x, остаётся неизменным фундаментом.  
DUN накладывается поверх неё и не требует никаких “особых” контейнеров или адресов.

---

## 2.2. DUN не вращает воксельную решётку

Локальная воксельная сетка DUN всегда **axis-aligned**:

```text
(local_x, local_y, local_z) ∈ [0..Nx) × [0..Ny) × [0..Nz)
```

* внутри DUN не существует “повёрнутого grid’а”;
* SVO / voxel grid живут в собственной осевой системе координат;
* любое вращение выполняется поверх этого слоя, а не за счёт изменения индексов.

Это сохраняет простую индексацию, корректную работу SVO/LOD и предсказуемость для EQ.

---

## 2.3. DUN вращается целиком как transform

Ротация DUN реализуется через его transform:

```rust
struct DunTransform {
    position: Vec3,
    rotation: Quat,
    scale: Vec3, // обычно (1,1,1)
}
```

* вращается весь узел целиком (mesh, OBB, визуальное представление);
* внутренние индексы и структура вокселей при этом не меняются.

Для **Static DUN** rotation может быть ограничен дискретными значениями (0/90/180/270°).
Для **Dynamic DUN** допускается полный quaternion (0–360°).

---

## 2.4. Физика и ходьба происходят по mesh, а не по raw-вокселям

Базовый принцип:

* воксели → описывают материал/плотность;
* surface mesh → описывает поверхность и используется для коллизий.

Пайплайн:

1. Внутри DUN хранится voxel grid / SVO (материал, разрушения, LOD).
2. Из этого объёма строится surface mesh (triangles).
3. Для физики и ходьбы используется mesh или производный collider, а не прямой обход по каждому вокселю.

Это избавляет от “ступенчатых” коллизий, держит физику в классической треугольной/примитивной форме
и оставляет воксельное представление внутренним, служебным уровнем.

---

## 2.5. AABB — локальный, OBB — мировой

DUN всегда содержит два типа ограничивающих объёмов:

* **локальный AABB** — в координатах DUN, axis-aligned;
* **мировой OBB** — результат применения `DunTransform` к локальному объёму.

Локальный AABB:

* используется HAOS/DTO и простыми алгоритмами;
* не зависит от rotation.

Мировой OBB:

* отражает реальную форму DUN в мире;
* используется физикой и точными проверками пересечений.

---

## 2.6. Route всегда остаётся логическим адресом DUN

У DUN всегда есть два взаимодополняющих описания положения:

* **Route** — где DUN “живёт” в топологии (Region/Block/Chunk/…);
* **Transform/position** — где DUN находится в float-пространстве в данный момент.

Инвариант:

* Route остаётся каноническим логическим адресом DUN;
* Transform не изменяет Route и не требует особых типов адресации.

Это позволяет:

* привязывать сохранения/стриминг к топологической сетке, а не к произвольным float;
* группировать DUN по регионам мира;
* хранить DUN в EQ-Core в тех же иерархиях, что и остальной мир.

---

## 2.7. Содержимое DUN может меняться, размеры — нет

DUN — это контейнер **фиксированного объёма**, заданного при его создании.

Под фиксированным объёмом понимается:

- фиксированное количество ячеек локальной решётки (Nx × Ny × Nz вокселей),
- фиксированная привязка этого объёма к мировым страйдам
  (например, 1 Chunk, 1 Octochunk, 2 Chunks столбом, группа Octochunks и т.п.).

Разрешено:

- менять воксели внутри (разрушать, добавлять, изменять материалы);
- обновлять SVO / density / локальные данные;
- проектировать разные типы DUN с разными фиксированными размерами
  (по одному чанку, по два чанка, loose-узлы и т.д.).

Запрещено:

- динамически изменять размеры уже существующего DUN
  (делать “особый” DUN другого размера на лету);
- “растягивать” или “сжимать” DUN за пределы его исходного объёма.

Если для задачи нужен другой размер (например, вместо 1 Chunk использовать 2 Chunks столбом),
создаётся **другой тип или экземпляр DUN** с собственной топологической привязкой и параметрами объёма.

### Размер DUN и топологические страйды

Инвариант “фиксированный объём DUN” **не означает**, что каждый DUN обязан быть
строго равен одному Chunk или Octochunk.

Архитектура допускает разные **классы DUN**, размер которых задаётся при проектировании:

- `DUN_Chunk` — один Chunk (например, 64×64×64 вокселей);
- `DUN_Octo` — один Octochunk (например, 32×32×32);
- `DUN_2Chunks_Vert` — два чанка столбом (например, 64×128×64);
- `DUN_4Octos_Tile` — плитка из 2×2 Octochunks по горизонтали;
- `DUN_LooseNode` — крупный loose-узел (например, 256×256×256) поверх нескольких базовых контейнеров.

Общие правила:

- размер **конкретного экземпляра DUN** выбирается при его создании  
  и остаётся неизменным на всём жизненном цикле;
- размеры DUN должны быть согласованы с топологией  
  (опираться на страйды базовых контейнеров: Chunk/Octo/Block/Region,  
  либо на их целочисленные комбинации);
- крупные структуры (корабли, здания, большие платформы) собираются **из нескольких DUN**,
  как из плиток, а не за счёт динамического “растягивания” одного DUN.

Таким образом:

- DUN остаётся **контейнером фиксированного объёма** на уровне экземпляра;
- при этом система остаётся гибкой — можно проектировать библиотеку разных типов DUN,
  адаптированных под нужные страйды, loose-узлы и схемы использования.

---

## 2.8. Итог: зачем нужны инварианты DUN

Инварианты DUN гарантируют, что эта сущность:

* **добавляет динамику поверх** триады *Topology / Routing / Rotation*, не изменяя её правил;
* остаётся **совместимой с long-term сохранениями и стримингом** (Route и топология стабильны во времени);
* даёт **чистую базу для физики и mesh-слоя** (коллизия и ходьба идут по surface mesh, а не по raw-вокселям);
* может использоваться в подсистемах **EQ-Core / EQ-Sim / HAOS** без специальных “особых случаев”;
* остаётся **простой и однозначной для других разработчиков**: явно видно, что именно делает DUN и чего он делать не может.

---

# 3. Anchor Model  

### Topology → Route → Float → Transform

DUN одновременно существует в четырёх слоях описания пространства:

1. **Topology Space** — дискретная топология мира  
2. **Route Space** — канонический адрес DUN в этой топологии  
3. **Float Space** — непрерывные координаты (runtime-позиция)  
4. **Transform Space** — полный transform (позиция + ротация + масштаб)

Anchor Model описывает, **как именно DUN “пришит” ко всем этим слоям одновременно**,  
и какие из них являются “твёрдым фундаментом”, а какие — динамикой поверх него.

---

## 3.1. Topology Space (дискретное пространство)

Топология мира (раздел 1.x) задаёт дискретную структуру:

> Region → Block → Chunk → Octochunk → Subchunk → Voxel

Она определяет:

- глобальное разбиение мира на контейнеры,
- границы и размеры каждого уровня,
- страйды и схемы индексации (в том числе Morton/flat),
- encode/decode формулы между индексами и координатами.

**DUN не меняет Topology Space.**  
Он лишь **ссылается** на уже существующие топологические сущности через Route.

---

## 3.2. Route Space (адрес)

**Route** — канонический дискретный адрес DUN в мире.  
Он указывает, к какому участку топологии DUN относится:

```text
Region / Block / Chunk / Octochunk / ... / [LocalIndex]
```

Route определяет:

* логическую принадлежность DUN миру,
* положение в дереве контейнеров (какой Region/Block/Chunk “родной”),
* точку “прикрепления” к топологии, с которой работают
  **EQ-Core**, стриминг и системы хранения.

При этом:

* Route **не хранит float-координаты**,
* Route **не описывает ротацию**,
* Route — это **дискретный идентификатор**, а не transform.

---

## 3.3. Float Space (runtime-позиция)

Для работы физики, камеры, рендера и симуляции DUN имеет
**непрерывное (float) положение в мировом пространстве**:

```rust
position: Vec3
```

Эта позиция:

* используется физическим движком (rigidbody, коллизии),
* используется рендером (мировая матрица для мешей),
* используется логикой симуляции (типы DUN, расстояния, триггеры).

При этом:

* изменение `position` **не меняет Route**,
* Topology/Route остаются базовой “картой мира”,
* Float Space — это **runtime-проекция** DUN в непрерывном мире.

---

## 3.4. Transform Space (позиция + кватернион + масштаб)

Полный transform DUN описывается структурой:

```rust
struct DunTransform {
    position: Vec3,  // мировая позиция опорной точки DUN
    rotation: Quat,  // ориентация DUN (полный диапазон 0–360°)
    scale: Vec3,     // обычно (1.0, 1.0, 1.0)
}
```

Transform Space определяет:

* **мировую OBB** DUN (через position + rotation),
* ориентацию и положение **surface-mesh’ей**,
* расположение **physics-collider’ов**,
* ротацию Dynamic DUN относительно мира.

Для Static DUN:

* `position` жёстко следует из Route (origin контейнера),
* `rotation` обычно ограничен дискретными значениями (0/90/180/270°)
  и может быть выражен через Rotation Layer.

Для Dynamic DUN:

* `position` свободно меняется во времени (Vec3),
* `rotation` — полноценный quaternion (анимация, физика, свободное вращение).

Transform **никогда не изменяет топологию** и **не влияет на Route**,
он только описывает, как DUN “сидит” в float-мире поверх дискретной структуры.

---

## 3.5. Связь между слоями (концептуально)

Для любого DUN можно мыслить цепочку:

```text
Topology Space  ──►  Route Space  ──►  Float Space  ──►  Transform Space
(структура мира)    (адрес DUN)       (позиция)         (позиция+ротация)
```

* Topology даёт **каркас** мира.
* Route определяет, **к какому месту каркаса** привязан DUN.
* Float-позиция задаёт **фактическое местоположение** DUN в мире.
* Transform добавляет **ротацию и масштаб** для рендера и физики.

В дальнейших документах (EQ-Core, EQ-Sim, HAOS) эта модель будет использоваться
как базовый “язык”, на котором описываются все операции над DUN
(стриминг, симуляция, оптимизации, сохранения).

## 3.6. Итог: зачем нужен Anchor Model

Anchor Model фиксирует, как DUN одновременно привязан к четырём слоям описания мира:

- **Topology Space** — задаёт жёсткую дискретную структуру мира, которую DUN не меняет.
- **Route Space** — даёт канонический адрес DUN и точку входа в топологию.
- **Float Space** — описывает runtime-позицию DUN для физики, рендера и логики.
- **Transform Space** — добавляет к позиции ротацию и масштаб (для Dynamic/Static режимов).

Благодаря этому:

- топология остаётся стабильным фундаментом;
- динамика DUN описывается через обычный transform, а не “особые координаты”;
- системы EQ-Core / EQ-Sim / HAOS могут работать с DUN на одном языке координат,
  не ломая триаду Topology / Routing / Rotation.

---

# 4. Ротация DUN и стабильность топологии

Ротация DUN — один из ключевых моментов, где легко “сломать” всю модель,  
если пытаться вращать сами воксели или контейнеры на уровне топологии.

В этом разделе фиксируется принципиальное правило:

> **вращается только DUN как transform,  
> внутренняя воксельная сетка остаётся осевой и статичной.**

---

## 4.1. Проблема вращения вокселей

Если пытаться вращать саму воксельную решётку (grid) DUN:

- нарушаются фиксированные **страйды** контейнеров  
  (воксели уже нельзя индексировать простыми линейными формулами);
- ломается или усложняется **Morton-кодирование и flat-индексация**  
  (битовые иерархии перестают соответствовать реальной геометрии);
- разрушается **иерархия контейнеров**  
  (Chunk / Octo / Subchunk больше не совпадают с “ровными” блоками пространства);
- усложняется или становится невозможным:
  - поиск соседей по целочисленным координатам,
  - кеширование участков (SVO, LOD),
  - использование одной и той же топологии для разных DUN.

Другими словами:

> вращаемая воксельная сетка = динамически искажённая топология,  
> с которой уже нельзя работать как с простой дискретной решёткой.

Чтобы этого не происходило, в архитектуре Arden вводится жёсткий инвариант:

> **локальная воксельная сетка DUN всегда axis-aligned и не вращается.**

---

## 4.2. Решение через transform

Ротация DUN реализуется не через изменение топологии или перестройку grid,  
а через обычный transform на уровне мешей и объёмов.

Последовательность работы:

1. **Воксели хранятся в локальных координатах (axis-aligned)**  
   Внутри DUN есть своя локальная воксельная решётка / SVO:
   
   (local_x, local_y, local_z) ∈ [0..Nx) × [0..Ny) × [0..Nz)

Она не вращается и не меняет ориентацию.

2. **Из вокселей извлекается surface mesh**
   Воксели интерпретируются как материал/плотность.
   На их основе строится один или несколько поверхностных мешей:

   * marching cubes / dual contour / greedy / другой алгоритм;
   * результат — набор треугольников в локальных координатах DUN.

3. **Mesh подчиняется transform DUN (position + rotation)**
   Для отрисовки и физики к mesh применяется:

   ```rust
   DunTransform { position: Vec3, rotation: Quat, scale: Vec3 }
   ```

   В результате меш целиком:

   * смещается в мировое пространство (position),
   * поворачивается (rotation),
   * масштабируется при необходимости (scale).

4. **Физика и рендер работают только с повёрнутым mesh**

   * рендер использует мировую матрицу трансформации,
   * физический движок использует collider, построенный на основе mesh или его упрощённой версии,
   * персонажи и объекты “стоят ногами” на surface mesh, а не на дискретных кубиках вокселей.

5. **Route и топология остаются нетронутыми**
   При любой ротации и движении DUN:

   * Route остаётся тем же (логический адрес),
   * Topology Space не изменяется,
   * encode/decode формулы, страйды и размеры контейнеров остаются валидными.

Итог:

* внешний мир видит DUN как объект, который может свободно вращаться и двигаться;
* внутренняя воксельная модель остаётся простой, осевой и стабильной;
* вся “сложность ротации” сосредоточена в Transform Space, а не в Topology Space.

## 4.3. Итог: почему ротация через transform

Ротация DUN реализуется только через transform (position + rotation), а не через поворот воксельной решётки. Это гарантирует, что:

- топология и Route остаются строгими и неизменными (страйды, encode/decode, контейнеры не ломаются);
- внутренняя воксельная структура остаётся простой и осевой, пригодной для SVO/LOD и индексации;
- вся непрерывная динамика (повороты, физика, “наклонные поверхности”) решается на уровне mesh и collider, где это естественно для движка.

Таким образом, **DUN может свободно вращаться в мире, не искажая базовую дискретную модель пространства**.

---

# 5. Внутренняя структура DUN (первый уровень)

Этот раздел описывает **минимальный каркас** данных, который должен быть у любого DUN.  
Это не окончательная структура для кода, а **концептуальный “паспорт” полей**,  
на который будут опираться EQ-Core, EQ-Sim, HAOS и специализированные DUN-доки  
(DUN.Mesh, DUN.Physics, DUN.Instance, DUN.Blueprint).

---

## 5.1. Концептуальная структура DUN

На концептуальном уровне DUN можно представить так:

```rust
DUN {
    // 1) Привязка к топологии
    route: Route,

    // 2) Transform (положение и ориентация в мире)
    transform: DunTransform,

    // 3) Локальные данные вокселей / объёма
    volume: DunVolume,

    // 4) Поверхностное представление (меши и коллайдеры)
    surface: DunSurface,

    // 5) Ограничивающие объёмы (bounding volumes)
    bounds: DunBounds,

    // 6) Состояние участия в симуляции/стриминге
    state: DunState,
}
```

Где подтипы раскрываются на первом уровне следующим образом.

---

## 5.2. Привязка к топологии

```rust
route: Route
```

**Route** — это канонический адрес DUN в дискретном мире:

* указывает, к какому Region / Block / Chunk / Octochunk относится DUN;
* используется EQ-Core, стримингом и подсистемами хранения;
* не содержит float-позиций и не описывает ротацию.

Это единственная точка, через которую DUN “видит” топологию
и остаётся совместим с триадой Topology / Routing / Rotation.

---

## 5.3. Transform DUN

```rust
struct DunTransform {
    position: Vec3,  // мировая позиция опорной точки DUN
    rotation: Quat,  // ориентация DUN (0–360°, для Dynamic DUN)
    scale: Vec3,     // обычно (1.0, 1.0, 1.0)
}
```

Transform описывает:

* где DUN находится в **float-пространстве**;
* как он ориентирован (особенно для Dynamic DUN);
* какой масштаб применяется к его surface-представлению.

Для **Static DUN**:

* `position` совпадает с origin, вычисленным из Route;
* `rotation` либо нулевая, либо дискретная (0/90/180/270°, через Rotation Layer);
* `scale` почти всегда `(1,1,1)`.

Для **Dynamic DUN**:

* `position` свободно перемещается;
* `rotation` — полноценный quaternion;
* `scale` чаще всего тоже единичный, но может быть расширен будущими доками.

---

## 5.4. Локальные объёмы: воксели и/или SVO

```rust
struct DunVolume {
    voxel_grid: Option<VoxelGrid>,  // регулярная решётка (если используется)
    svo_tree:   Option<SvoTree>,    // sparse-структура (LOD/SVO, если используется)
    local_aabb: Aabb,               // AABB в локальных координатах DUN
}
```

**DunVolume** описывает “начинку” DUN:

* `voxel_grid` — локальная воксельная решётка (axis-aligned), если нужна;
* `svo_tree` — разреженное дерево для оптимизаций, LOD и сложных форм;
* `local_aabb` — минимальный AABB, который покрывает весь объём DUN
  в его **локальной системе координат**.

Главное:

* воксельная структура не вращается;
* DunVolume живёт в локальном пространстве DUN.

---

## 5.5. Поверхностное представление (меши и коллайдеры)

```rust
struct DunSurface {
    meshes: Vec<MeshId>,        // один или несколько surface mesh'ей
    collider: PhysicsCollider,  // форма для физики (на базе mesh или примитивов)
}
```

**DunSurface** отвечает за всё, с чем взаимодействует:

* рендер (модели, поверхности, LOD-меши),
* физика (коллизии, стояние персонажа, raycast).

Ключевые моменты:

* meshes строятся из DunVolume (вокселей / SVO);
* при рендере и физике к mesh применяется `DunTransform`;
* персонаж “стоит” на mesh, а не на raw-вокселях.

---

## 5.6. Ограничивающие объёмы (bounding volumes)

```rust
struct DunBounds {
    aabb_local: Aabb, // axis-aligned в локальном пространстве DUN
    obb_world: Obb,   // ориентированный бокс в мировом пространстве
}
```

**DunBounds** связывает локальную и мировую геометрию:

* `aabb_local`:

  * используется HAOS / DTO и простыми алгоритмами;
  * всегда axis-aligned, не зависит от rotation;
  * может совпадать с DunVolume.local_aabb или быть агрегированным.

* `obb_world`:

  * вычисляется из `aabb_local` + `DunTransform`;
  * описывает реальный объём DUN в мировом пространстве;
  * используется физикой и точным broad-phase.

---

## 5.7. Состояние DUN

```rust
enum DunState {
    Active,      // участвует в симуляции и обновлениях
    Dormant,     // присутствует, но не тикает
    Archived,    // выгружен/сохранён, отсутствует в памяти как полнотелый объект
    TempLoaded,  // только что загружен, ещё не вошёл в активный цикл
}
```

**DunState** описывает участие DUN в:

* симуляции,
* стриминге,
* оптимизациях.

Алгоритмы переходов между состояниями не описываются в этом документе
и будут заданы в EQ-Sim / HAOS. Здесь фиксируется только **набор допустимых статусов**.

---

## 5.8. Итог: роль внутренней структуры DUN

Внутренняя структура DUN задаёт **минимальный единый формат**, к которому могут обращаться:

* EQ-Core (как к структуре хранения и состояния),
* EQ-Sim (как к единице симуляции),
* HAOS/DTO (как к объекту оптимизации и сна/пробуждения),
* Mesh/Render-подсистемы (как к носителю surface-геометрии),
* Physics (как к носителю collider’ов и объёмов).

Это **не финальная структура данных в коде**, а архитектурный каркас:
конкретные поля и типы могут расширяться в отдельных документах (`DUN.Mesh`, `DUN.Physics`, `DUN.Instance`),
но базовые группы полей и их смысл должны оставаться неизменными.

---

# 6. Состояния DUN

Состояние DUN определяет, **насколько активно этот узел участвует в симуляции и стриминге**,  
и какие подсистемы имеют право с ним работать в текущий момент.

На уровне структуры (см. 5.7) это представлено как `DunState`,  
здесь фиксируется **семантика** этих состояний.

---

## 6.1. Назначение состояний

Состояния DUN нужны для того, чтобы:

- разграничить **активные** и **спящие** участки мира;
- позволить HAOS/DTO управлять загрузкой и выгрузкой узлов;
- дать EQ-Sim понятный сигнал: этот DUN нужно тикать / не нужно тикать;
- уменьшить нагрузку на CPU/GPU при большом количестве DUN.

Состояние — это **флаг уровня архитектуры**,  
а не конкретная реализация алгоритмов сна/пробуждения.

---

## 6.2. Семантика состояний DunState

```rust
enum DunState {
    Active,
    Dormant,
    Archived,
    TempLoaded,
}
```

### **Active**

DUN находится в активной фазе:

* участвует в тиках симуляции;
* его Transform может изменяться (особенно для Dynamic DUN);
* его surface/mesh может обновляться;
* физика и логика взаимодействий учитывают этот DUN.

Типичные случаи:

* подвижные объекты (Dynamic DUN);
* чанки рядом с игроком;
* области, где сейчас происходят изменения.

---

### **Dormant**

DUN находится в “спящем” состоянии:

* данные DUN присутствуют в памяти (volume, surface, bounds);
* Transform не меняется (или меняется крайне редко);
* DUN не тикает каждый кадр/шаг симуляции;
* физика может считать его статической геометрией (по mesh/collider’у);
* HAOS/DTO могут разбудить DUN при необходимости.

Типичные случаи:

* дальние участки мира, которые видимы, но не активно изменяются;
* статические объекты, к которым давно не было обращений.

---

### **Archived**

DUN выгружен из активной памяти:

* полные данные (volume, surface, bounds) могут быть сохранены на диск или в сжатом виде;
* в оперативной памяти может остаться только “тонкая” запись (Route, ID, метаданные);
* DUN не участвует ни в симуляции, ни в рендере;
* может быть восстановлен в TempLoaded / Active при стриминге.

Типичные случаи:

* регионы, к которым игрок давно не подходил;
* серверные snapshot’ы мира.

---

### **TempLoaded**

Промежуточное состояние:

* DUN только что подтянут из `Archived`;
* данные восстановлены частично или полностью;
* ещё не включён в основной симуляционный цикл;
* может быть подготовлен HAOS/DTO и затем переведён в Active или Dormant.

Типичные случаи:

* подгрузка чанка перед появлением игрока;
* восстановление динамического объекта из сохранения.

---

## 6.3. Ответственность подсистем

* **EQ-Core** отвечает за консистентность данных DUN в каждом состоянии
  (что именно обязано быть в памяти: только Route, Route+Volume, полный объект).

* **EQ-Sim** отвечает за то, какие состояния участвуют в тике
  (обычно только `Active`, иногда частично `Dormant` для статических объектов).

* **HAOS/DTO** отвечают за переходы между состояниями
  (когда “усыпить”, когда “разбудить”, когда “архивировать”).

В этом документе фиксируется только **сам набор состояний и их смысл**.
Конкретные правила переходов будут описаны в EQ-документах.

---

# 7. Почему DUN не ломает Topology / Routing / Rotation

DUN изначально спроектирован как **надстройка над триадой 1.x**,
а не как её модификация. Здесь фиксируются архитектурные гарантии,
почему добавление DUN не разрушает:

* Topology Space (структуру контейнеров),
* Route Space (адресацию),
* Rotation Layer (дискретные повороты в топологии).

---

## 7.1. Гарантии относительно Topology Space

DUN:

* **не меняет размеры контейнеров** (Region/Block/Chunk/Octo и т.п.);
* **не меняет страйды** и схемы индексации;
* **не вмешивается в encode/decode формулы** координат и Route;
* **не вращает** воксельную решётку (`voxel_grid`, `svo_tree` остаются axis-aligned).

Следствие:

* все свойства, доказанные и описанные в документах Topology/Route,
  остаются валидными независимо от количества и поведения DUN;
* любые алгоритмы, опирающиеся на строгую топологию (поиск соседей, Morton, SVO/LOD),
  могут работать, не зная о существовании DUN.

---

## 7.2. Гарантии относительно Route Space

DUN:

* всегда имеет **один канонический Route** (логический адрес в мире);
* не меняет структуру Route и правила его построения;
* не требует “особых” видов Route для Static/ Dynamic режимов;
* использует Route только как **якорь** для:

  * хранения,
  * стриминга,
  * группировки по регионам.

Следствие:

* системы сохранения и загрузки могут работать с DUN так же, как с любыми другими сущностями,
  опираясь на Route как на “координаты в дискретном мире”;
* Topology + Route остаются “единой картой мира”, к которой DUN лишь привязывается.

---

## 7.3. Гарантии относительно Rotation Layer

Rotation Layer (из 1.x):

* описывает дискретные повороты контейнеров (0/90/180/270°),
* используется там, где нужны “жёсткие” повороты, совместимые с топологией.

DUN:

* не изменяет набор дискретных ротаций в Rotation Layer;
* не требует введения новых дискретных состояний в топологии;
* использует **Transform Space** (Quat) только на уровне mesh / collider / OBB.

Static DUN:

* может использовать Rotation Layer (дискретные повороты) в качестве своей ориентации.

Dynamic DUN:

* использует quaternion-ротацию поверх уже существующей топологии,
  не добавляя новых состояний в Rotation Layer.

Следствие:

* Rotation Layer остаётся самодостаточной системой для дискретных поворотов;
* непрерывные повороты DUN не требуют изменений в триаде.

---

## 7.4. Гарантия разделения слоёв

В сумме DUN обеспечивает **жёсткое разделение слоёв**:

* Topology / Route / Rotation — описывают **глобальное дискретное пространство**;
* DUN — описывает **локальные динамические узлы** в этом пространстве;
* Transform / Mesh / Physics — описывают **конкретное поведение и геометрию** DUN.

DUN работает **поверх** триады, используя её как фундамент,
но не меняя её определений, формул и инвариантов.

Именно поэтому:

> добавление DUN делает мир динамичным и интерактивным,
> но не превращает топологию в “плавающую” или нестабильную систему.

---

# 8. Место DUN в архитектуре и дальнейшие документы

Раздел 2.x фиксирует DUN как **минимальную динамическую единицу мира**, построенную **поверх** триады:

- Topology / Routing / Rotation (1.x) — жёсткий дискретный фундамент;
- DUN (2.x) — локальные динамические узлы;
- Transform / Mesh / Physics — непрерывное поведение и геометрия поверх DUN.

Этот документ задаёт:

- определение DUN (Static / Dynamic режимы);
- инварианты (что DUN делает и чего не делает);
- Anchor Model (Topology → Route → Float → Transform);
- правила ротации через transform;
- базовую внутреннюю структуру и состояния DUN.

Дальнейшие уровни архитектуры не меняют эти правила, а опираются на них.

---

## 8.1. Связь с документами 1.x (Topology / Routing / Rotation)

Документы 1.x описывают:

- дискретную топологию мира (иерархия Region → Block → Chunk → Octochunk → …),
- схемы адресации Route,
- дискретный Rotation Layer.

DUN:

- не изменяет ни размеры контейнеров, ни страйды, ни encode/decode Route;
- не вращает воксельную решётку;
- использует Route как логический якорь и точку входа в топологию;
- добавляет над этим слоем только transform, mesh, collider и состояния.

Таким образом, **1.x остаются “законами мироздания”**,  
а DUN — управляемым “жителем” этого мира.

---

## 8.2. Связь с будущими EQ-документами (3.x)

Следующий крупный блок архитектуры — серия документов **3.x (EQ / Simulation Layer)**:

- **EQ-Core**  
  Описывает, как ядро мира хранит DUN:
  - таблицы/реестры DUN,
  - связь Route → DUN,
  - format для сохранений и стриминга,
  - какие поля DUN обязаны быть консистентны в каждом состоянии (Active / Dormant / Archived).

- **EQ-Sim**  
  Описывает, как DUN участвует в тике симуляции:
  - кто тикает только `Active`, кто частично `Dormant`,
  - как используется `DunState` в шагах симуляции,
  - как учитывается Transform / Anchor Model при логике.

- **HAOS (Hybrid Adaptive Optimization System)**  
  Описывает, как оптимизируется активность DUN:
  - переходы между Active / Dormant / Archived / TempLoaded,
  - бюджеты на DUN по регионам, классам и семействам,
  - взаимодействие с DTO (системами сна/пробуждения) и bounding-объёмами.

Все эти подсистемы работают **на уже установленных инвариантах DUN**  
и не меняют его базового контракта.

---

## 8.3. Специализированные DUN-документы

Поверх этого базового документа планируются отдельные уточняющие спецификации:

- **DUN.Mesh**  
  - как из DunVolume (voxel_grid / SVO) строятся surface mesh’и,
  - политика LOD и обновления mesh при изменении вокселей,
  - связь mesh-слоя с Transform и Render.

- **DUN.Physics**  
  - как из DunBounds и mesh формируются collider’ы,
  - какие типы тел используются для Static / Dynamic DUN,
  - правила использования AABB/OBB в физике и broad-phase.

- **DUN.Blueprint**  
  - шаблоны DUN (стены, модули, корабли, структуры),
  - параметры разрушения/фрагментации, предварительные mesh/volume-заготовки,
  - связь blueprint’ов с EQ-Core/стримингом.

- **DUN.Instance**  
  - runtime-представление Dynamic DUN,
  - связь экземпляра с blueprint’ами,
  - дополнительные поля, нужные только во время симуляции (таймеры, локальные контроллеры и т.п.).

Каждый из этих документов **не переопределяет** базовый контракт DUN,  
а лишь детализирует отдельные аспекты: геометрию, физику, шаблоны, инстансы.

---

## 8.4. Что считать стабильным, а что может меняться

Считаются **стабильными** и не подлежащими произвольной смене:

- определение DUN как Dynamic Unit Node;
- разделение Static / Dynamic режимов;
- Anchor Model (Topology → Route → Float → Transform);
- инварианты 2.x (топология, Route, ротация, mesh / voxel, AABB / OBB, фиксированный объём);
- базовая структура DUN (route, transform, volume, surface, bounds, state);
- набор состояний DunState.

Могут эволюционировать в будущих версиях:

- конкретные поля внутри DunVolume / DunSurface / DunBounds;
- расширения для DUN.Instance / DUN.Blueprint;
- стратегии управления состояниями DUN в EQ-Sim и HAOS;
- дополнительные подклассы DUN под конкретные задачи (вода, большие структуры, FX и т.п.).

---

## 8.5. Итог

Этот документ фиксирует DUN как:

> **атомарный узел динамического мира Arden,  
> который добавляет движение, ротацию и физику,  
> не ломая строгую дискретную топологию ядра.**

Все последующие архитектурные документы (1.x, 3.x и специализированные DUN-модули)  
будут опираться на описанные здесь инварианты и модель якорения,  
чтобы сохранить целостность проекта и понятный контракт для разработчиков и исследователей.
