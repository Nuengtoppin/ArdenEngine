# **1.0. Обзор / mini-README раздела Routing**

Раздел Routing формирует **каноническую модель маршрута (Route)** — адресного пути в мире,
который опирается на топологию (Region → Block → Chunk → Octochunk → Voxel) и координаты,
но живёт **выше** их, как отдельный слой.

Routing отвечает на вопросы:

* как представить положение точки или области **как путь через уровни**;
* как один и тот же маршрут понимать во всех подсистемах одинаково;
* как преобразовывать Route в координаты и обратно;
* как сравнивать, смещать, сокращать и логировать маршруты.

Route — это **не просто набор чисел**, а:

* структурированная сущность с инвариантами,
* единый “язык адресов” для генерации, симуляции, LOD/SVO, DTO/HAOS, редакторов и инструментов.

---

## **1.0.1. Что задаёт Routing**

Раздел 1.x (Routing) фиксирует:

* **Понятие маршрута (Route)**
  * полный путь через уровни:
    `Region → Block → Chunk → Octochunk → Voxel`;
  * сокращённые формы (Region+Voxel, Region+Chunk, Chunk+Voxel и т.п.);
  * структуру Route как объекта (какие поля есть всегда, какие опциональны).

* **Инварианты и валидность Route**
  * Region и Octant — всегда присутствуют;
  * локальные координаты всегда неотрицательны и в пределах топологии;
  * порядок уровней фиксирован и не меняется;
  * Route согласован с топологией и формулами координат.

* **Связь Route с топологией и координатами**
  * как из Route получить XYZ (и Region+LocalFloat) с опорой на топологию;
  * как из XYZ (signed/float) восстановить Route;
  * как работать с полными и сокращёнными маршрутами.

* **Базовые операции над Route**
  * сравнение и порядок (равенство, лексикографический порядок);
  * принадлежность и вложенность (Block содержит Chunk, Chunk содержит Voxel и т.д.);
  * смещение (offset) через координаты;
  * подъём/опускание по уровням (Up/Down, parent/children);
  * нормализация маршрута.

* **Текстовое представление Route**
  * канонический человекочитаемый формат строки маршрута;
  * правила сокращения (как пропускать уровни без потери смысла);
  * требования к обратимости (строка ↔ Route).

Routing не вводит новую математику пространства,  
а использует **уже заданную топологию и координатную модель** как фундамент,  
предлагая над ними единый адресный протокол.

---

## **1.0.2. Структура раздела 1.x (Routing по блокам)**

План раздела:

**1.1. Понятие Route и область применения**  
Вводит Route как абстрактную сущность:

* чем Route отличается от “просто набора индексов”;
* какие бывают маршруты (полный и сокращённые формы);
* в каких задачах Route используется (генерация, DTO/HAOS, LOD, редакторы, логирование).

---

**1.2. Каноническая структура Route**  
Формально описывает:

* какие поля содержит Route (Region, Octant, Block, Chunk, Octochunk, Voxel);
* какие уровни обязательны, какие — опциональны;
* как выглядят полный и частичный (partial) маршруты;
* как Route соотносится с иерархией топологии, но не дублирует её.

---

**1.3. Инварианты и правила валидности**  
Фиксирует строгие условия:

* Region и Octant всегда присутствуют;
* диапазоны координат соответствуют топологии;
* порядок уровней неизменен;
* Route ↔ координаты (XYZ / Region+LocalFloat) обратим;
* сокращённые маршруты остаются формально корректными.

Это “контракт”, который должен выполнять любой Route в системе.

---

**1.4. Связь Route с топологией и координатами**  
Описывает, как Route:

* опирается на топологию (раздел Topology);
* преобразуется в абсолютные координаты и обратно:
  * Route → XYZ / Region+LocalFloat,
  * XYZ → Route (через нормализацию и октанты);
* как сокращённый маршрут дополняется контекстом (известный Region/Block).

---

**1.5. Операции над Route**  
Определяет канонический набор операций:

* сравнение маршрутов (равенство, порядок);
* принадлежность и вложенность (contains/within);
* смещение (offset по вектору);
* подъём/опускание между уровнями (Up/Down);
* нормализация.

Эти операции используются всеми подсистемами, которые работают с адресами.

---

**1.6. Строковое представление маршрутов (RouteString)**  
Вводит человекочитаемый формат:

* общие требования (канон, обратимость, компактность, читаемость);
* структура строки и порядок уровней;
* правила сокращения (как пропускать уровни);
* примеры корректных и некорректных строк.

---

**1.7. Связь Routing с системами движка**  
Кратко описывает, как Route используется:

* в DTO (активность/сон областей),
* в HAOS (распределение нагрузки),
* в LOD/SVO (узлы дерева),
* в генерации (сид, шум, структуры),
* в ECS (ключи сущностей),
* в рендере (flat/Morton индексы).

Это не API и не алгоритмы, а обзор того, **где именно Route служит общим языком**.

---

## **1.0.3. Как читать этот раздел**

* Если нужно понять, **что такое Route и зачем он** — достаточно 1.1–1.2.  
* Если важны **строгие гарантии и корректность** — 1.3.  
* Если ты работаешь с координатами и конвертациями — 1.4.  
* Если пишешь системы, которые хранят и двигают адреса — 1.5.  
* Если делаешь отладочные инструменты, CLI, форматы логов — 1.6.  
* Если проектируешь DTO/HAOS/LOD/генерацию/рендер — 1.7 как обзор точек входа.

Раздел 1.x (Routing) стоит читать как **паспорт адресного протокола мира**:  
он не диктует геймплей и алгоритмы, но задаёт правила,  
по которым все подсистемы обязаны работать с адресами в одном языке.

# **1.1. Понятие Route и область применения**

Routing вводит абстракцию **Route** — адресного пути в мире, который опирается
на топологию (Region → Block → Chunk → Octochunk → Voxel), но живёт
как отдельный логический слой поверх координат и контейнеров.

Route — это:

* представление положения точки или области **как пути через уровни**;
* связующее звено между:
  * координатами (глобальными и локальными),
  * топологией (иерархией контейнеров),
  * системами динамики (DTO/HAOS),
  * прикладными подсистемами (генерация, LOD, навигация, симуляция, инструменты);
* фундаментальная единица адресации, с которой работают почти все системы движка.

Route не подменяет ни топологию, ни координаты.
Он задаёт **общий адресный протокол**, который все подсистемы обязаны понимать одинаково.

---

## **1.1.1. Route как сущность**

Route рассматривается как **каноническая форма адреса**, а не как “набор индексов”.

В общем виде Route:

* связывает все уровни:
  `Region → Block → Chunk → Octochunk → Voxel`,
* использует знаковую модель октантов (A–I) для направления,
* может быть:
  * **полным** (full route) — включает все уровни,
  * **сокращённым** (partial route) — включает только те уровни, которые нужны задаче.

Примеры:

* Полный путь до конкретного вокселя:

  ```text
  Region → Block → Chunk → Octochunk → Voxel

* Сокращённые формы:

  * `Region + Voxel` — когда важна абсолютная воксельная позиция в регионе;
  * `Region + Chunk` — когда система работает на уровне чанков (LOD, SVO, culling);
  * `Block + Chunk` — для генерации или симуляции в пределах крупного объёма;
  * `Chunk + Voxel` — для локальной работы в известном чанке (редактор, локальная физика).

Route:

* может быть представлен как структура в коде,
* сериализирован в бинарном или текстовом виде,
* отображён в человекочитаемом формате для логов и инструментов,
* всегда согласован с топологией и координатной моделью.

---

## **1.1.2. Задачи, которые решает Routing**

Слой Routing вводит единый объект Route, чтобы:

* **Связать все уровни пространства**

  Route — это “сквозной” путь через:

  * Region (макросетка и стриминг),
  * Block (крупные зоны активности/генерации),
  * Chunk (основная единица геометрии),
  * Octochunk (локальная динамика / микро-LOD),
  * Voxel (атомарная точка).

* **Сделать адрес самостоятельной сущностью**

  Route рассматривается как объект, который:

  * можно сравнивать (равенство, порядок),
  * смещать (offset в сторону),
  * обрезать/поднимать/опускать по уровням,
  * сериализовать и логировать,
  * использовать как ключ во всех подсистемах.

* **Обеспечить стабильный encode/decode**

  Все операции Route ↔ координаты опираются на математику топологии
  (см. документ Topology), а Routing фиксирует:

  * что является “правильным” маршрутом,
  * какие поля обязательны,
  * какие формы считаются корректными для разных задач.

---

## **1.1.3. Область применения Route в движке**

Route используется в большинстве высокоуровневых подсистем:

* **Игровая логика и симуляция**

  * определение, в каком чанке/регионе находится объект;
  * триггеры и зоны: “игрок вошёл в Block/Chunk/Region”;
  * запуск событий в конкретных областях.

* **Генерация**

  * адресация областей для генераторов высоты, структур, биомов;
  * привязка сидов шума к Region/Block/Chunk через Route;
  * воспроизводимое восстановление той же области по тому же маршруту.

* **LOD / SVO и пространственные деревья**

  * Route как идентификатор узла уровня Chunk/Octo;
  * построение и обход иерархий через операции Up/Down;
  * сортировка и выборка зон по Route (flat index, Morton).

* **DTO / HAOS**

  * включение/выключение активности регионов, блоков, чанков;
  * приоритезация обновлений по маршрутам;
  * разбиение мира на “волны” обновлений с привязкой к Route.

* **Инструменты и отладка**

  * логирование пути в человекочитаемом виде;
  * поиск объектов и областей по Route;
  * переход в инспекторе к конкретному Region/Chunk/Voxel по маршруту.

* **ECS, сериализация, рендер**

  * Route как ключ/ID для сущностей и чанков;
  * сохранение/загрузка мира по маршрутам;
  * использование Route для построения GPU-буферов, индексов и зон видимости.

---

## **1.1.4. Route как “язык обмена” между подсистемами**

Главная идея:

> Разные подсистемы могут иметь разную внутреннюю реализацию,
> но **Route остаётся для них общим языком адресации**.

* Генератор террейна, DTO-система, LOD, стриминг и редактор могут:

  * использовать различные структуры данных и алгоритмы,
  * но обмениваться областями и точками через Route.

Это позволяет:

* не дублировать логику адресации в каждой системе,
* менять внутренние реализации без изменения контрактов,
* строить новые модули R&D, опираясь на уже заданный язык маршрутов.

---

# **1.2. Каноническая структура Route**

Route опирается на фиксированную иерархию уровней топологии:

Region → Block → Chunk → Octochunk → Voxel


и знаковую модель октантов (A–I), но сам по себе является **логической структурой**, описывающей путь через эти уровни.

Route не хранит “произвольные” поля — он строго следует топологии и координатной модели.

---

## **1.2.1. Состав уровней Route**

В общем случае Route включает следующие логические компоненты:

- **RegionCoord** — индекс региона в мире:
  - `(rx, rz, ry)` — целочисленные индексы региона по осям.
- **Octant** — знаковая модель направления:
  - одна из букв `A, B, C, D, E, F, G, I` (см. октанты в топологии).
- **BlockCoord** — координата блока внутри региона:
  - `(bx, bz, by)` — локальные индексы блока.
- **ChunkCoord** — координата чанка внутри блока:
  - `(cx, cz, cy)` — локальные индексы чанка.
- **OctochunkCoord** — координата окточанка внутри чанка:
  - `(ox, oz, oy)` — локальные индексы окточанка.
- **VoxelCoord** — локальная координата вокселя:
  - `(vx, vz, vy)` — координаты вокселя внутри Octochunk
    (или внутри Region/Chunk при сокращённых формах).

При этом:

* индексы уровней всегда **неотрицательны** и лежат в диапазонах,
  заданных топологией (см. документ Topology);
* знак направления по осям X/Z/Y хранится **не в индексах**, а в октанте и индексах Region.

---

## **1.2.2. Полный маршрут (Full Route)**

**Полный Route** — это маршрут, в котором явно указаны все уровни:

```text
Region → Block → Chunk → Octochunk → Voxel

Концептуально:

* RegionCoord определяет, **какой регион** мира используется;
* Octant задаёт **ориентацию по знакам X/Z/Y**;
* BlockCoord, ChunkCoord, OctochunkCoord задают, **где именно внутри региона** находится область;
* VoxelCoord указывает **конкретную точку**.

Полный Route используется, когда требуется:

* максимально точная идентификация точки/ячейки;
* логирование полного пути;
* копирование/перенос областей вместе с их структурой;
* работа нескольких подсистем одновременно (LOD + DTO + генерация и т.д.).

Полный Route — это **максимально информативная адресная форма**.

---

## **1.2.3. Сокращённые маршруты (Partial Route)**

Во многих задачах нет необходимости хранить все уровни.
Вместо этого используется **partial Route** — маршрут, который включает только нужные уровни.

Примеры типичных сокращённых форм:

* **Region + Voxel**

  ```text
  Region → Voxel
  ```

  Применение:

  * редакторы и тесты;
  * прямой доступ к вокселю в пределах региона;
  * быстрые raycast/проверки без явного перечисления Block/Chunk/Octo.

* **Region + Chunk**

  ```text
  Region → Chunk
  ```

  Применение:

  * LOD/SVO, culling;
  * стриминг чанков;
  * coarse-логика (крупный шаг по миру).

* **Block + Chunk**

  ```text
  Block → Chunk
  ```

  Применение:

  * генерация и симуляция в пределах крупного объёма;
  * SVO/LOD на уровне блока.

* **Chunk + Voxel**

  ```text
  Chunk → Voxel
  ```

  Применение:

  * локальная работа в известном чанке;
  * редактирование;
  * локальная физика и эффекты.

**Важно:**

* сокращённый Route — это не “обрезанный”,
  а *специализированный маршрут* под конкретную задачу;
* любой partial Route:

  * остаётся согласованным с топологией,
  * может быть дополнен до полной формы (при наличии контекста),
  * может быть использован в преобразованиях Route ↔ координаты.

---

## **1.2.4. Обязательные и опциональные компоненты**

С точки зрения архитектуры:

* **RegionCoord** — всегда обязателен
  (Route всегда существует *внутри* какого-то региона мира).

* **Octant** — всегда обязателен
  (задаёт знаки осей и обеспечивают нормализацию signed-векторов).

* **Block / Chunk / Octochunk / Voxel** — **опциональны**
  (могут отсутствовать в зависимости от задачи).

Это можно представить как абстрактную структуру:

```text
Route {
    region   = RegionCoord       // обязательно
    octant   = Octant            // обязательно

    block    = (есть / нет)
    chunk    = (есть / нет)
    octo     = (есть / нет)
    voxel    = (есть / нет)
}
```

При этом:

* порядок уровней **всегда фиксирован**:
  `Region → Block → Chunk → Octochunk → Voxel`;
* “пропуск уровня” означает отсутствие данных на этом уровне,
  но **не меняет** позиций остальных уровней в цепочке.

---

## **1.2.5. Представления Route**

Архитектура допускает несколько представлений одного и того же Route:

1. **Структурное представление**
   *Основное для систем движка.*

   Route хранится как набор полей, соответствующих уровням топологии.
   Это форма, с которой работают генерация, LOD, DTO, ECS и др.

2. **Текстовое (человекочитаемое) представление**
   Используется:

   * в логах,
   * инструментах,
   * отладочных панелях.

   Формат фиксируется отдельно (см. Topology/1.6),
   но всегда должен быть **однозначно обратим в структурный Route**.

3. **Упакованное / бинарное представление**
   Используется:

   * для сериализации,
   * сетевых протоколов,
   * GPU-буферов.

   Конкретный формат (битовые маски, порядок полей) может меняться от реализации к реализации,
   но обязан:

   * сохранять все обязательные компоненты Route,
   * быть обратно преобразуемым в структурную форму,
   * не нарушать инварианты (см. Topology/1.3).

---

## **1.2.6. Независимость от языка и реализации**

Структура Route описывается:

* на уровне **логики и инвариантов**,
* а не конкретного языка программирования или формата хранения.

Это означает:

* реализация на Rust, C++, Python или другом языке
  может отличаться по форме (struct, class, record),
  но всё равно обязана:

  * содержать Region и Octant как обязательные уровни,
  * трактовать Block/Chunk/Octo/Voxel как опциональные уровни,
  * соблюдать фиксированный порядок и диапазоны координат,
  * поддерживать обратимость Route ↔ координаты.

**Route — это часть архитектуры, а не только структура кода.**
Он задаёт модель адресного пути, которой должны следовать все реализации.

---

# **1.3. Инварианты и правила валидности Route**

Route — это не произвольный набор полей, а объект с чёткими архитектурными ограничениями.
Инварианты фиксируют связь:

* между Route и топологией (см. Topology/1.1–1.2),
* между Route и координатами (см. Topology/1.4, Topology/1.6),

и гарантируют, что любой корректный маршрут согласован с моделью мира.

Инварианты обязательны для:

* сериализации и десериализации,
* преобразований Route ↔ координаты,
* работы DTO/HAOS, LOD/SVO, генерации и редакторов,
* любых R&D-систем, которые опираются на Route как на “язык адресов”.

---

## **1.3.1. Структурные инварианты**

### Region всегда присутствует

Любой Route существует **внутри какого-то региона** мира.

Route.region ∈ ℤ³   // (rx, rz, ry)

Route без уровня Region не считается валидным, так как:

* локальные координаты Block/Chunk/Octo/Voxel определяются относительно Region;
* преобразования Route ↔ глобальные координаты невозможны без региона.

---

### Octant всегда присутствует

Octant — это часть адресной модели, задающая знаки осей X/Z/Y:


Route.octant ∈ {A, B, C, D, E, F, G, I}

Он обязателен, потому что:

* кодирует направление относительно центра (см. Topology/1.3 — октанты),
* участвует в нормализации signed-вектора → адресная модель,
* обеспечивает обратимость преобразований координат.

Route без Octant считается некорректным.

---

### Порядок уровней фиксирован

Порядок уровней в Route **не изменяется**:

```text
Region → Block → Chunk → Octochunk → Voxel
```

Инварианты:

* уровни не могут меняться местами;
* уровень “ниже” (Chunk, Octo, Voxel) не может появиться, если отсутствует весь контекст выше, если маршрут заявлен как глобальный;
* сокращённые маршруты (partial Route) могут пропускать уровни, но **не нарушают** порядок (см. 1.2.3).

Примеры:

*Допустимо:*

```text
Region → Chunk
Region → Voxel
Chunk → Voxel      // при локальном контексте чанка
```

*Недопустимо:*

Chunk без Region (глобальный адрес)
Voxel без Region и Octant
Block после Chunk (нарушен порядок)

---

### Локальные координаты всегда неотрицательные

Route никогда не хранит отрицательные локальные координаты.

Инвариант:

```text
bx, bz, by ≥ 0
cx, cz, cy ≥ 0
ox, oz, oy ≥ 0
vx, vz, vy ≥ 0
```

*Все диапазоны локальных координат заданы топологией
(см. Topology/1.2, Topology/1.5).*

Знак координат (верх/низ, лево/право, вперёд/назад):

* хранится в `Region` (индексы региона могут быть signed),
* и в `Octant` (знаковая модель направления),
* но **не** в локальных индексах Block/Chunk/Octo/Voxel.

---

### Опциональные уровни не ломают структуру

Уровни ниже Region могут быть:

* заданы явно (есть координаты),
* или отсутствовать (маршрут более “крупного масштаба”).

Инвариант:

* “пропуск уровня” — это **отсутствие данных на этом уровне**,
  а не изменение порядка или переинтерпретация других уровней;
* даже если уровень пропущен, его позиция в логической цепочке
  остаётся фиксированной.

Это важно для:

* сериализации (маски уровней),
* обобщённых операций (Up/Down),
* работы partial Route в одном и том же формате.

---

## **1.3.2. Диапазоны координат и согласованность с топологией**

Все числовые поля Route должны соответствовать диапазонам,
определённым топологией (см. Topology/1.2, Topology/1.5).

Для канонической конфигурации (Chunk = 64³, Octochunk = 32³):

```text
0 ≤ bx < 8
0 ≤ by < 2
0 ≤ bz < 8

0 ≤ cx < 8
0 ≤ cy < 8
0 ≤ cz < 8

0 ≤ ox < 2
0 ≤ oy < 2
0 ≤ oz < 2

0 ≤ vx < OCTO_SIZE      // 32
0 ≤ vy < OCTO_SIZE
0 ≤ vz < OCTO_SIZE
```

Инварианты:

* Route не может содержать локальные индексы вне этих диапазонов;
* при масштабировании Chunk/Octochunk (см. Topology/1.2.3)
  скорректированные диапазоны должны быть учтены во всех валидациях Route;
* любые операции (offset, Up/Down, normalize) обязаны возвращать Route
  с координатами внутри корректных диапазонов.

---

## **1.3.3. Обратимость и согласованность с координатами**

Route связан с координатами через математику топологии
(см. Topology/1.4 — координатная модель, Topology/1.6 — прямые/обратные переходы).

Инвариант обратимости:

```text
decode(encode(Route)) == Route
```

где:

* `encode(Route)` → глобальные координаты (XYZ или Region+LocalFloat),
* `decode(XYZ)` → Route.

Требования:

1. **Route → координаты**

   * Полный Route должен однозначно преобразовываться
     в абсолютные координаты (целочисленные или float-представление) мира.
   * Сокращённый Route должен корректно:

     * либо расширяться до полной формы через известный контекст (например, “текущий Region”),
     * либо иметь чётко определённое отображение (например, “Region+Chunk” → координаты чанка).

2. **Координаты → Route**

   * Любая корректная комбинация координат (XYZ / Region+LocalFloat)
     должна быть нормализована в Route с согласованными:

     * Region,
     * Octant,
     * локальными индексами уровней.
   * Нормализация учитывает знаки осей и использует октанты
     согласно Topology/1.3.

3. **Согласованность обоих направлений**

   * Если система использует Route как основной источник истины,
     координаты должны быть воспроизводимы.
   * Если система хранит только координаты, восстановленный Route
     должен быть структурно корректен и удовлетворять всем инвариантам.

---

## **1.3.4. Валидность сокращённых маршрутов (Partial Route)**

Сокращённые маршруты считаются валидными,
если они соблюдают общие инварианты и имеют однозначную семантику.

Примеры корректных partial Route:

* `Region + Voxel`
  Адресует конкретный воксель в пределах региона.
  Требования:

  * `Region` и `Octant` заданы,
  * координаты `v(x|z|y)` не выходят за диапазон Region (см. Topology/1.2).

* `Region + Chunk`
  Адресует чанк как область фиксированного размера.
  Требования:

  * координаты чанка соответствуют топологии,
  * Route может быть преобразован в диапазон вокселей (VoxelRange) этой области.

* `Chunk + Voxel`
  Используется в локальном контексте (например, редактор уже “знает” текущий Region/Block).
  Требования:

  * чётко определён внешний контекст, в котором этот Route интерпретируется,
  * преобразование в глобальные координаты возможно и детерминировано.

---

### Ограничения partial Route

Недопустимы варианты, у которых:

* невозможно однозначно восстановить позицию в мире;
* отсутствуют обязательные компоненты (Region, Octant) при глобальной интерпретации;
* нарушен порядок уровней;
* локальные координаты выходят за допустимые диапазоны.

---

## **1.3.5. Согласованность между уровнями Route**

Для полного Route дополнительно вводится инвариант согласованности:

* координаты нижнего уровня должны находиться **внутри** контейнера уровня выше.

Примеры:

* Voxel должен принадлежать Octochunk, указанному в Route;
* Octochunk должен принадлежать Chunk;
* Chunk — Block;
* Block — Region.

Это означает:

* нельзя, чтобы `vx` указывал на координату вне границ Octochunk;
* нельзя, чтобы ChunkCoord ссылался на зону, выходящую за границы BlockCoord;
* нельзя, чтобы BlockCoord указывал на область вне Region.

Данный инвариант критичен для:

* генерации;
* SVO/LOD;
* обновления мешей;
* DTO/HAOS (переходы активности по уровням).

---

## **1.3.6. Итог по инвариантам Route**

Инварианты Route гарантируют, что:

* любой маршрут:

  * лежит внутри топологии,
  * имеет корректную структуру,
  * может быть преобразован в координаты и обратно;
* сокращённые маршруты остаются формально валидными
  и пригодными для глобальной или локальной интерпретации;
* любые реализации (Rust, C++, ECS, сетевые протоколы, бинарные форматы)
  обязаны соблюдать эти правила, чтобы считаться совместимыми с архитектурой.

Route — это **не просто удобная структура**,
а строго определённая сущность с контрактом валидности,
которая делает возможным единый адресный протокол для всего мира.

---

# **1.4. Связь Route с топологией и координатами**

Route не живёт сам по себе — он опирается на:

* топологию контейнеров  
  (`Region → Block → Chunk → Octochunk → Voxel`, см. Topology/1.1–1.2),
* координатную модель  
  (глобальные signed XYZ и локальные индексы, см. Topology/1.4),
* страйды и размеры уровней  
  (см. Topology/1.6).

Этот раздел фиксирует, **как именно Route связывается**:

1. с дискретными мировыми координатами (целочисленные XYZ),
2. с непрерывным представлением внутри Region (Region + LocalFloat).

---

## **1.4.1. Два слоя координат**

Архитектура различает два слоя координат:

1. **Дискретный слой (целочисленный)**

   * глобальные signed координаты мира:

     ```text
     X_abs ∈ ℤ
     Z_abs ∈ ℤ
     Y_abs ∈ ℤ
     ```

   * используются:
     * физикой на сетке,
     * навигацией по целым шагам,
     * дискретной симуляцией,
     * генерацией, привязанной к voxel/chunk.

2. **Непрерывный слой (float внутри Region)**

   * координата внутри региона в виде:

     ```text
     (fx, fz, fy) ∈ [0 .. REGION_SIZE_XZ) × [0 .. REGION_SIZE_XZ) × [0 .. REGION_SIZE_Y)
     ```

   * хранит **плавное положение** внутри региона:
     * движение объектов,
     * интерполяции,
     * камеры,
     * точные точки столкновения.

Route сам по себе — **дискретный объект** (индексы и октант).  
Связь с float-позицией строится через Region и локальные диапазоны.

---

## **1.4.2. Route → дискретные мировые координаты (XYZ_int)**

Полный Route может быть однозначно преобразован в дискретные мировые координаты:

```text
Route → (X_abs, Z_abs, Y_abs) ∈ ℤ³
````

Общая идея:

1. Берём:

   * `region` (rx, rz, ry),
   * `block` / `chunk` / `octo` / `voxel` (если присутствуют),
   * страйды уровней (см. Topology/1.6).

2. Складываем смещения уровней:

   ```text
   X_abs = f_x(region, block, chunk, octo, voxel)
   Z_abs = f_z(...)
   Y_abs = f_y(...)
   ```

   (конкретные формулы даны в Topology/1.6 — прямые переходы вниз).

3. Применяем знак через:

   * `region` (signed индексы),
   * `octant` (знаковая модель направления по X/Z/Y).

Результат:

* любая точка, представленная полным Route,
  получает **целочисленную позицию** в мировых координатах;
* любые системы, работающие с XYZ_int, могут использовать Route как источник.

Для **partial Route**:

* если он содержит достаточный набор уровней (например, Region+Chunk),
  может быть вычислен диапазон или базовый XYZ для всей области (Chunk-объём);
* детали зависят от того, как именно partial Route интерпретируется в конкретной системе
  (Chunk как куб вокселей, Block как крупная область и т.д.).

---

## **1.4.3. XYZ_int → Route (нормализация координат)**

Обратная операция:

```text
(X_abs, Z_abs, Y_abs) → Route
```

использует математику нормализации (см. Topology/1.4, Topology/1.6):

1. По глобальным XYZ определяем:

   * `region` через целочисленное деление/остатки по страйдам Region,
   * локальные координаты внутри Region.

2. Через размеры уровней:

   * вычисляем `Block`, `Chunk`, `Octochunk`, `Voxel`
     последовательным делением/остатками,
   * гарантируя попадание в корректные диапазоны (см. 1.3.2).

3. Определяем `Octant` по знакам:

   ```text
   sx = sign(X_abs)
   sz = sign(Z_abs)
   sy = sign(Y_abs)

   → Octant ∈ {A,B,C,D,E,F,G,I}
   ```

4. Собираем Route:

   ```text
   Route {
       region = (rx, rz, ry),
       octant = Octant,
       block  = ...,
       chunk  = ...,
       octo   = ...,
       voxel  = ...
   }
   ```

Инвариант:

```text
decode(encode(Route)) == Route
```

при условии, что:

* используются одни и те же страйды и диапазоны,
* учтены правила знаков и октантов из Topology/1.3.

---

## **1.4.4. Непрерывное представление: Region + LocalFloat**

Чтобы совместить **топологию** и **плавное движение**, вводится связка:

```text
RegionCoord + Octant + LocalFloat
```

Где:

* `RegionCoord (rx, rz, ry)` — задаёт регион мира;
* `Octant` — задаёт направление (знаки осей);
* `LocalFloat (fx, fz, fy)` — описывает **плавную позицию** внутри Region:

  ```text
  fx ∈ [0 .. REGION_SIZE_XZ)
  fz ∈ [0 .. REGION_SIZE_XZ)
  fy ∈ [0 .. REGION_SIZE_Y)
  ```

Такое представление:

* позволяет объектам двигаться по float-координатам,
  не теряя связи с топологией;
* даёт единый язык для физики / камер / навигации:

  * физика оперирует LocalFloat,
  * топология — индексами и Route,
  * а между ними есть детерминированный мост.

---

## **1.4.5. Route ↔ Region + LocalFloat**

Route и непрерывное представление внутри Region связаны через страйды (см. Topology/1.6).

### Из Route в LocalFloat

Имея полный Route:

```text
Region, Block, Chunk, Octo, Voxel
```

можно:

1. вычислить **локальные целочисленные координаты внутри Region**:

   ```text
   (X_local_int, Z_local_int, Y_local_int)
   ```

2. получить float-позицию, например:

   ```text
   fx = X_local_int + offset_x
   fz = Z_local_int + offset_z
   fy = Y_local_int + offset_y
   ```

где `offset_*`:

* 0.0 — привязка к “углу” вокселя/ячейки;
* 0.5 — привязка к центру вокселя (частый вариант для физики).

Так Route задаёт **якорь** в дискретной сетке,
а LocalFloat — положение внутри той же структуры с нужной “гранулярностью”.

---

### Из LocalFloat в Route

Имея:

```text
RegionCoord, Octant, (fx, fz, fy)
```

можно:

1. взять целую часть:

   ```text
   X_local_int = floor(fx)
   Z_local_int = floor(fz)
   Y_local_int = floor(fy)
   ```

2. разложить их обратно:

   * в Block/Chunk/Octo/Voxel
   * через целочисленное деление/остаток (см. Topology/1.6).

3. собрать Route, удовлетворяющий всем инвариантам (см. 1.3).

Дробная часть (`fract(fx)`, `fract(fz)`, `fract(fy)`) может использоваться:

* физикой и рендером,
* для интерполяций, нормалей, смещений внутри вокселя,
* но **сама по себе не входит** в Route — маршрут остаётся дискретным.

---

## **1.4.6. Контекст для partial Route**

Для сокращённых маршрутов (partial Route) связь с координатами зависит от контекста.

Примеры:

* **Chunk + Voxel**
  Контекст: “текущий Region/Block уже известен системе”.

  Система:

  * знает RegionCoord,
  * добавляет к нему Chunk/Voxel из Route,
  * получает XYZ / LocalFloat в глобальном мире.

* **Region + Chunk**
  Контекст: Route рассматривается как “адрес области”.

  Можно получить:

  * базовый XYZ угла чанка,
  * диапазон VoxelRange (воксельный куб),
  * float-бокс для генерации/LOD/коллизии.

* **Region + Voxel**
  Однозначное соответствие:

  * Route → XYZ_int (точка сетки),
  * Route → LocalFloat (внутренняя float-точка, с выбранным offset).

---

## **1.4.7. Итог: единый язык между индексами и float-вектором**

Связка:

```
Route ↔ (XYZ_int) ↔ (Region + LocalFloat)
```

даёт:

* единый язык между:

  * топологией (индексы уровней),
  * дискретными мировыми координатами,
  * непрерывным float-представлением внутри Region;
* возможность:

  * свободно перемещаться float-вектором,
  * в любой момент “проецировать” положение в Route и обратно,
  * использовать один и тот же Route для:

    * генерации,
    * физики/навигации,
    * LOD/SVO,
    * DTO/HAOS,
    * рендера и инструментов.

Route остаётся **дискретным фундаментом адресации**,
а слой `Region + LocalFloat` — непрерывной оболочкой вокруг него,
через которую двигаются объекты, камеры и системы R&D.

## **1.4.8. Практическое использование LocalFloat (строгий vs упрощённый режим)**

Модель `Region + LocalFloat` допускает два практических варианта использования,
в зависимости от требований системы.

### Вариант A — упрощённый (Region + LocalFloat)

Во многих задачах (движение объектов, камера, простая физика) достаточно:

```text
RegionCoord (rx, rz, ry)
LocalFloat (fx, fz, fy) ∈ [0..REGION_SIZE_XZ) × [0..REGION_SIZE_XZ) × [0..REGION_SIZE_Y)
```

Особенности:

* `LocalFloat` интерпретируется как **позиция внутри региона** без учёта октанта.
* Системе не требуется знать знаки осей X/Z/Y — она работает только в пределах Region.
* При необходимости перехода к Route или дискретной топологии:

  * `LocalFloat` приводится к целым индексам (floor),
  * на основе индексов вычисляются Block/Chunk/Octo/Voxel (см. Topology/1.6),
  * `Octant` может быть определён отдельно (из глобального XYZ или внешнего контекста).

Этот режим минимизирует сложность и подходит как “рабочий” для большинства локальных систем.

---

### Вариант B — строгий (Region + Octant + LocalFloat)

При необходимости полностью следовать зеркальной XZ-модели и знаковой семантике
можно использовать расширенную связку:

```text
RegionCoord + Octant + LocalFloat
```

Где:

* `LocalFloat` по-прежнему хранит расстояния ≥ 0 внутри Region,
* направление (лево/право, север/юг, верх/низ) кодируется через `Octant`
  (см. Topology/1.3 — знаковая модель).

Особенности:

* координатная модель становится полностью согласованной с моделью индексов:

  * модуль (расстояние) → в LocalFloat/индексы,
  * знак → в Octant/Region;
* упрощается доказательство биекции между:

  * signed XYZ,
  * Route,
  * LocalFloat.

Этот режим сложнее по реализации, но даёт максимально строгую и симметричную математику.

---

**Рекомендация**

Архитектура Routing и Topology поддерживает **оба варианта**:

* упрощённый (`Region + LocalFloat`) — как базовый практический инструмент;
* строгий (`Region + Octant + LocalFloat`) — как расширенный режим
  для систем, которым критична полная согласованность со знаковой моделью и ротациями.

Конкретная реализация движка может начать с упрощённого режима
и при необходимости эволюционировать к строгому, не ломая фундаментальные инварианты.

---

# **1.5. Операции над Route**

Этот раздел фиксирует базовый набор операций над маршрутами (Route),
которые считаются частью архитектурного контракта.

Операции используются:

* игровыми системами (логика, перемещения, триггеры),
* генераторами,
* LOD/SVO-структурами,
* DTO/HAOS,
* инструментами и отладкой,
* системами сериализации.

Все операции обязаны:

* соблюдать инварианты Route (см. 1.3),
* оставаться согласованными с топологией (см. Topology/1.1–1.2),
* корректно работать с полными и сокращёнными маршрутами (см. 1.2.3).

---

## **1.5.1. Сравнение маршрутов (Equality / Ordering)**

### Равенство

Два маршрута считаются равными, если:

1. совпадает `region` (все три компоненты),
2. совпадает `octant`,
3. совпадают все присутствующие уровни (`block`, `chunk`, `octo`, `voxel`),
4. отсутствующие уровни отсутствуют с обеих сторон.

Концептуально:

```text
Route A == Route B  ⇔
    A.region == B.region
 AND A.octant == B.octant
 AND A.block  == B.block
 AND A.chunk  == B.chunk
 AND A.octo   == B.octo
 AND A.voxel  == B.voxel
```

Особенности:

* сравнение **структурное**, а не по произвольному ID;
* сокращённые маршруты сравниваются по тем полям, которые действительно есть;
* валидность и диапазоны уровней предполагаются проверенными при создании Route (см. 1.3).

---

### Лексикографический порядок

Для сортировки маршрутов вводится лексикографический порядок уровней:

```text
Region < Block < Chunk < Octochunk < Voxel
```

Типичный порядок сравнения:

1. по `region`,
2. затем по `block`,
3. затем по `chunk`,
4. затем по `octo`,
5. затем по `voxel`.

Этот порядок важен для:

* построения деревьев (B-деревья, SVO-надстройки),
* приоритизации обновлений (например, “внутри региона сортировать по чанкам”),
* последовательной загрузки/выгрузки областей,
* детерминированного обхода мира.

---

## **1.5.2. Принадлежность и вложенность (Contains / Within)**

Route может описывать:

* область (Region, Block, Chunk, Octochunk),
* или точку (Voxel).

Операция “принадлежности” проверяет, лежит ли один маршрут **внутри контейнера** другого.

Общая идея:

```text
Container.contains(Child) == true
```

если:

1. уровни Container находятся **выше или на том же уровне**, что и Child,
2. все координаты Container совпадают с соответствующей частью Child.

Примеры:

* **Region содержит любой Route с тем же RegionCoord**:

  ```text
  RegionRoute.contains(ЛюбойRouteСТемЖеRegion) == true
  ```

* **Block содержит Chunk**:

  ```text
  BlockRoute.contains(ChunkRoute) == true
  ```

* **Chunk содержит Voxel** (при полной форме Chunk+Voxel):

  ```text
  ChunkRoute.contains(VoxelRoute) == true
  ```

Ограничения:

* контейнер не может быть ниже по уровню, чем проверяемый Route:

  * `Chunk.contains(Block)` — всегда `false`,
  * `Voxel.contains(Chunk)` — всегда `false`.
* для сокращённых маршрутов (например, только `Chunk` без `Region`)
  принадлежность корректно определяется только в контексте,
  где Region уже известен.

---

## **1.5.3. Смещение маршрута (Offset)**

Смещение используется для:

* перемещения объектов,
* проходов генерации,
* сканирования соседних зон,
* “шага” по сетке в логике/AI.

Смещение представляется как signed-вектор:

```text
(dx, dz, dy)
```

Операция смещения:

```text
Route' = offset(Route, dx, dz, dy)
```

выполняется в три шага:

1. **Route → дискретные мировые координаты (XYZ_int)**
   (см. 1.4.2, Topology/1.6 — прямые формулы)

2. **Применение смещения в пространстве координат**

   ```text
   X' = X_abs + dx
   Z' = Z_abs + dz
   Y' = Y_abs + dy
   ```

3. **Нормализация XYZ_int → Route'**
   (см. 1.4.3 — нормализация координат в Route)

Инварианты:

* результат `Route'` должен быть корректен (см. 1.3),
* смещение может менять Region, Octant и все уровни ниже,
* операция полностью обратима при противоположном векторе:

  ```text
  offset(offset(Route, dx, dz, dy), -dx, -dz, -dy) == Route
  ```

---

## **1.5.4. Переход между уровнями (Up / Down)**

Операции Up/Down определяют переход между уровнями топологии
по фиксированному порядку:

```text
Region → Block → Chunk → Octochunk → Voxel
```

и используются в:

* LOD/SVO,
* DTO/HAOS (активность по уровням),
* генерации (разбиение/агрегация),
* инструментах (навигация по уровням).

---

### Опускание (Down)

Опускание переводит Route на **более низкий уровень**.

Примеры:

* `Region → Blocks`
* `Block → Chunks`
* `Chunk → Octochunks`
* `Octochunk → Voxels` (как диапазон/итератор)

Результат:

* либо один дочерний Route (например, при выборе конкретного Chunk),
* либо набор дочерних Route (массив или итератор по всем детям).

Инварианты:

* все дочерние маршруты имеют тот же Region и Octant,
* координаты уровня-родителя фиксированы,
* координаты уровня-детей перебирают допустимый диапазон (см. Topology/1.2, 1.5).

---

### Поднятие (Up)

Поднятие переводит Route на **более высокий уровень**.

Примеры:

* `Voxel → Octochunk`
* `Octochunk → Chunk`
* `Chunk → Block`
* `Block → Region`

Общая идея:

* соответствующие индексы делятся на размер уровня и “сворачиваются” до родительского контейнера,
* Octant и Region остаются неизменными.

Особенности:

* поднятие обычно не восстанавливает исходный Route
  (информация о точной позиции внутри контейнера теряется),
* результат рассматривается как “контейнер, внутри которого лежит исходный Route”.

---

### Нормализация Route

Нормализация — это проверка и приведение Route к **канонической форме**.

Операция нормализации:

* проверяет, что:

  * все диапазоны координат в допустимых пределах (см. 1.3.2),
  * порядок уровней не нарушен,
  * значения согласованы с топологией;
* при необходимости:

  * обрезает/исправляет некорректные значения,
  * может поднимать Route на более высокий уровень при выходе за диапазон,
  * либо помечает Route как невалидный (в зависимости от политики реализации).

Рекомендуется вызывать нормализацию:

* после ручной сборки Route,
* после операций offset / Up / Down,
* после десериализации из внешних форматов.

---

## **1.5.5. Route и диапазоны (VoxelRange / Area)**

Часть систем работает **с областями**, а не с одиночными точками:

* генерация (структуры, биомы),
* LOD (чанк-объёмы),
* DTO/HAOS (области активности),
* обновление мешей.

Route может:

* представлять **ядро области** (например, Chunk как центр),
* либо быть **однозначно развёрнут** в диапазон:

  ```text
  Route_chunk → VoxelRange(64×64×64)
  Route_octo  → VoxelRange(32×32×32)
  ```

Интерфейс уровня архитектуры:

* Route определяет **ячейку и её размер** (по топологии — см. Topology/1.2),
* любая система может восстановить диапазон вокселей/координат, зная:

  * тип уровня (Chunk/Octo),
  * его размеры,
  * Route.

---

## **1.5.6. Кэширование результатов операций**

Некоторые Route используются часто:

* текущий Chunk игрока,
* активные Chunk/Octo для DTO/HAOS,
* фронт LOD,
* границы зоны стриминга.

Чтобы не повторять дорогостоящие преобразования (Route ↔ XYZ, Route ↔ Morton, Route ↔ FlatIndex), допускается кэшировать:

* абсолютные координаты XYZ_int,
* локальные координаты внутри Region,
* плоские индексы (flat index),
* Morton-код (для Octo/Voxel уровней).

Архитектура не навязывает конкретный формат кэша,
но исходные операции (см. 1.4 и 1.7) считаются **источником истины**,
а кэш — производной оптимизацией.

---

## **1.5.7. Итог по операциям Route**

Базовые операции над Route дают:

* строгие правила сравнения и сортировки маршрутов;
* понятие принадлежности и вложенности областей;
* механизм смещения адресов через вектор движения;
* переходы между уровнями (Up/Down) с сохранением топологии;
* нормализацию и проверку корректности;
* связь маршрутов с диапазонами (областями) и возможность их кэширования.

На этом уровне Route формируется как **полноценный рабочий объект**,
с которым подсистемы движка могут уверенно:

* хранить адреса,
* передавать их между системами,
* применять к ним операции без нарушения инвариантов.

---

# **1.6. Строковое представление маршрутов (RouteString)**

Этот раздел задаёт **канонический текстовый формат** маршрутов.

RouteString используется в:

- логах и отладке,
- консольных/CLI-инструментах,
- редакторах и инспекторах,
- временных R&D-утилитах.

Формат должен быть:

- однозначно обратимым → `RouteString → Route`,
- каноническим (для одного Route — одна строка),
- достаточно компактным и читабельным,
- независимым от конкретной реализации (Rust/C++ и т.д.).

---

## **1.6.1. Общая структура строки**

Маршрут записывается как **последовательность сегментов**, разделённых символом `/`:

```text
R(...) / <Octant> / B(...) / C(...) / O(...) / v(...)
````

Где:

* `R(...)` — регион (RegionCoord),
* `<Octant>` — буква `A,B,C,D,E,F,G,I`,
* `B(...)` — блок (BlockCoord),
* `C(...)` — чанк (ChunkCoord),
* `O(...)` — окточанк (OctoCoord),
* `v(...)` — воксель (VoxelCoord).

Примеры:

```text
R(0|0|0) / A / B(3|4|0) / C(1|2|5) / O(0|1|1) / v(3|14|2)

R(-1|0|2) / G / C(7|0|3) / v(10|32|4)

R(0|0|0) / D / v(300|1800|120)
```

---

## **1.6.2. Правила записи для уровней**

### Region

Регион задаётся тройкой целых чисел:

```text
R(rx|rz|ry)
```

Где:

* `rx, rz, ry ∈ ℤ` — индексы региона по осям (см. Topology/1.2, Topology/1.3).

Примеры:

```text
R(0|0|0)
R(1|0|0)
R(-3|5|-1)
```

---

### Octant

Октант записывается одной буквой:

```text
A B C D E F G I
```

Примеры:

```text
A
D
G
I
```

Октант **обязателен** для любых глобальных маршрутов
(см. 1.3.1 — Octant всегда присутствует).

---

### Block / Chunk / Octochunk

Каждый из этих уровней задаётся тройкой неотрицательных индексов:

```text
B(bx|bz|by)
C(cx|cz|cy)
O(ox|oz|oy)
```

Где диапазоны индексов зависят от топологии (см. Topology/1.2, Topology/1.5).

Примеры:

```text
B(3|4|0)      // bx=3, bz=4, by=0
C(1|2|5)
O(0|1|1)
```

---

### Voxel

Воксель записывается как:

```text
v(x|z|y)
```

Где:

* `x, z, y` — локальные координаты вокселя в пределах контейнера
  (Octochunk или Region/Chunk для сокращённых форм),
* порядок осей **строго** `x | z | y`
  (см. Topology/1.3 — канонический порядок осей).

Примеры:

```text
v(3|14|2)
v(10|32|4)
v(300|1800|120)
```

---

## **1.6.3. Обязательные и опциональные сегменты**

**Обязательные сегменты** для глобального маршрута:

* `R(...)`
* `<Octant>`

**Опциональные сегменты**:

* `B(...)`
* `C(...)`
* `O(...)`
* `v(...)`

Сегменты всегда идут в фиксированном порядке:

```text
R(...) / Octant / B(...) / C(...) / O(...) / v(...)
```

Если уровень отсутствует, соответствующий сегмент **полностью опускается**.

Примеры:

* Полный маршрут:

  ```text
  R(0|0|0) / A / B(3|4|0) / C(1|2|5) / O(0|1|1) / v(3|14|2)
  ```

* Region + Chunk:

  ```text
  R(0|0|0) / D / C(7|0|3)
  ```

* Region + Voxel:

  ```text
  R(0|0|0) / A / v(300|1800|120)
  ```

* Только Chunk + Voxel (локальный контекст чанка):

  ```text
  C(7|0|3) / v(12|30|4)
  ```

(В последнем случае глобальная интерпретация зависит от внешнего контекста,
см. 1.4.6.)

---

## **1.6.4. Сокращённые формы (Partial RouteString)**

RouteString допускает сокращённые формы, соответствующие partial Route (см. 1.2.3).

**Примеры допустимых сокращений:**

* Region + Voxel:

  ```text
  R(0|0|0) / A / v(300|1800|120)
  ```

* Region + Chunk:

  ```text
  R(-1|0|2) / G / C(7|0|3)
  ```

* Region + Block:

  ```text
  R(1|0|0) / A / B(5|3|1)
  ```

* Chunk + Voxel (локально):

  ```text
  C(7|0|3) / v(12|30|4)
  ```

**Недопустимые варианты:**

* без Region и Octant при попытке трактовать как глобальный адрес;

* нарушение порядка сегментов:

  ```text
  R(...) / C(...) / B(...)      // неправильно
  ```

* пропуск Region при наличии Octant:

  ```text
  A / C(7|0|3)                  // неправильно
  ```

---

## **1.6.5. Обратимость и парсинг**

Для строкового формата вводится инвариант:

```text
parse( format(Route) ) == Route
```

Требования к парсеру:

1. Строка должна разбиваться по `/` на сегменты слева направо.
2. Каждый сегмент должен иметь один из допустимых префиксов:

   * `R(`…`)`
   * `B(`…`)`
   * `C(`…`)`
   * `O(`…`)`
   * `v(`…`)`
   * либо быть одиночной буквой октанта `A,B,C,D,E,F,G,I`.
3. Порядок сегментов должен соответствовать порядку уровней.
4. Все числовые значения должны попадать в допустимые диапазоны
   (см. Topology/1.2, Topology/1.5).
5. Отсутствующий сегмент означает отсутствие уровня, а не “нулевой индекс”.

Примеры корректных строк:

```text
R(0|0|0) / A / C(7|0|3) / v(12|30|4)
R(-1|5|0) / F / B(3|4|1)
R(2|0|-1) / D
```

Примеры некорректных строк:

```text
R(0|0|0) / C(7|0|3)          // нет октанта
A / C(7|0|3)                 // нет региона
R(0|0|0) / A / v(99999|0|0)  // выход за диапазон региона
R(0|0|0) / A / C(7|0|3) / B(1|2|0)  // нарушен порядок уровней
```

---

## **1.6.6. Расширения формата (метки и теги)**

Формат RouteString может дополняться **метаданными**, которые не влияют на сам Route, но несут дополнительную информацию для инструментов.

Пример синтаксиса:

```text
R(0|0|0) / A / C(7|0|3) / v(12|30|4) @lod(2) @seed(12345) #cave !active
```

Рекомендуемые префиксы:

* `@key(value)` — параметр (seed, lod, generation-stage, и т.п.),
* `#tag` — произвольный тег,
* `!flag` — булевый флаг.

Требования:

* парсер Route должен уметь **игнорировать** эти расширения,
  если они ему не нужны;
* базовая часть строки (Region/Octant/…/v) должна оставаться
  полностью корректной и обратимой в Route.

---

## **1.6.7. Итог по строковому формату**

Строковый формат Route:

* задаёт **единый человекочитаемый вид** маршрутов,
* полностью обратим в структурный Route,
* поддерживает как полные, так и сокращённые формы,
* не ломает инварианты топологии и координат,
* допускает аккуратные расширения через метаданные.

RouteString — это “поверхностный” язык для людей и инструментов,
который строго следует глубинной модели Route и Topology.

---

# **1.7. Mapping-API — интерфейс работы с Route**

Этот раздел фиксирует **минимальный набор операций сопоставления** (mapping),
который должен быть доступен всем подсистемам движка для работы с Route.

Цель Mapping-API:

* дать единый способ:
  * получать ID уровней из Route,
  * получать индексы (flat / Morton),
  * переходить Route ↔ дискретные координаты (XYZ_int),
  * переходить Route ↔ Region + LocalFloat;
* скрыть от систем внутренние детали формул и страйдов
  (см. Topology/1.6),
* сделать поведение всех подсистем согласованным.

Mapping-API описывается на уровне **контрактов функций**,  
конкретный язык реализации (Rust/C++/другое) не фиксируется.

---

## **1.7.1. Route → идентификаторы уровней**

Базовые функции извлечения ID уровней из маршрута.

### RegionID

```text
region_id(route) -> (rx, rz, ry)
```

* Возвращает координаты Region уровня.
* Не зависит от того, заполнены ли нижние уровни (`block/chunk/...`).

---

### BlockID / ChunkID / OctoID / VoxelCoord

```text
block_id(route)      -> (bx, bz, by)   // если block присутствует
chunk_id(route)      -> (cx, cz, cy)   // если chunk присутствует
octo_id(route)       -> (ox, oz, oy)   // если octo присутствует
voxel_coord(route)   -> (vx, vz, vy)   // если voxel присутствует
```

Требования:

* при отсутствии уровня (partial Route) функция:

  * либо возвращает “пустой” результат (None/ошибка),
  * либо вообще не вызывается — в зависимости от политики языка;
* диапазоны возвращаемых значений **гарантированно валидны**
  (см. Topology/1.5.2, инварианты 1.3).

---

## **1.7.2. Route → индексы (Flat / Morton)**

### Flat-индексы для уровней

Flat-индекс — однозначное отображение 3D-индекса уровня в 1D-значение:

```text
flat_index_chunk(route)      -> u32
flat_index_octo(route)       -> u32
flat_index_block(route)      -> u32
flat_index_region_local(route) -> u32   // опционально
```

Использует:

* размеры и страйды уровня (см. Topology/1.6),
* канонический порядок осей `x | z | y` (см. Topology/1.3).

Инварианты:

* `0 ≤ flat_index < (size_x * size_z * size_y)` для уровня,
* существует обратное преобразование `flat_index → (x,z,y)`.

---

### Morton-индексы

Для уровней, где требуется иерархическая локальность (SVO/LOD):

```text
morton_voxel(route) -> u32    // по (vx, vz, vy)
morton_octo(route)  -> u32    // по (ox, oz, oy)
```

Требования:

* используется только для неотрицательных локальных координат (см. Topology/1.3),
* порядок битового перемежения — `x | z | y` (см. Topology/1.8),
* операции encode/decode должны быть строгими и обратимыми.

---

## **1.7.3. Route ↔ дискретные координаты (XYZ_int)**

### Route → XYZ_int

```text
route_to_xyz(route) -> (X_abs, Z_abs, Y_abs) ∈ ℤ³
```

Использует:

* Region/Block/Chunk/Octo/Voxel,
* страйды (см. Topology/1.6),
* знаковую модель (Region + Octant, см. Topology/1.3, Routing/1.4).

Инварианты:

* результат — дискретная мировая координата точки или базовой ячейки;
* при полном Route (включая voxel) соответствие однозначно.

---

### XYZ_int → Route

```text
xyz_to_route(X_abs, Z_abs, Y_abs) -> Route
```

Алгоритм:

1. Определить Region по целочисленному делению/остаткам (см. Topology/1.6).
2. Нормализовать локальные координаты Region в Block/Chunk/Octo/Voxel.
3. Определить Octant по знакам компонент.
4. Собрать Route, удовлетворяющий инвариантам 1.3.

Инвариант:

```text
xyz_to_route( route_to_xyz(Route) ) == Route
```

при условии, что Route полон и нормализован.

---

## **1.7.4. Route ↔ Region + LocalFloat**

### Route → Region + LocalFloat

```text
route_to_region_local(route, mode) -> (RegionCoord, LocalFloat)
```

Где:

* `RegionCoord = (rx, rz, ry)`,
* `LocalFloat = (fx, fz, fy)` в диапазоне Region
  (см. Topology/1.4, 1.4.8),
* `mode` задаёт правило привязки:

  * к углу ячейки (`corner`),
  * к центру (`center`),
  * к произвольному смещению (например, `center_of_voxel`).

Общая схема:

1. Route → локальные целочисленные координаты внутри Region.
2. Добавить выбранное смещение (offset) → получить float-позицию.

---

### Region + LocalFloat → Route

```text
region_local_to_route(RegionCoord, LocalFloat) -> Route
```

Общая схема:

1. Взять `floor` от локальных координат → целочисленные `X_local_int, Z_local_int, Y_local_int`.
2. Разложить их по уровням (Block/Chunk/Octo/Voxel) через деление/остаток.
3. Построить Route с валидными диапазонами.

При необходимости:

* Octant может определяться:

  * либо из глобального контекста (например, при наличии глобальных XYZ),
  * либо задаваться явно внешней системой.

---

## **1.7.5. Уровневые отношения (Same / Adjacent)**

Mapping-API вводит базовые предикаты для сравнения уровней через Route.

### Совпадение уровней

```text
same_region(a, b) -> bool
same_block(a, b)  -> bool
same_chunk(a, b)  -> bool
same_octo(a, b)   -> bool
```

Семантика:

* `same_chunk(a, b) == true`, если:

  * у обоих маршрутов есть заполненный уровень chunk,
  * `region_id(a) == region_id(b)`,
  * `chunk_id(a)  == chunk_id(b)`.

Аналогично для остальных уровней.

---

### Соседство уровней

```text
adjacent_chunks(a, b)  -> bool
adjacent_blocks(a, b)  -> bool
```

Общая идея:

* уровни совпадают по Region,
* разница координат уровня ≤ 1 по каждой оси.

Пример:

```text
adjacent_chunks(a, b) == true
⇔ same_region(a,b)
 ∧ |cx_a - cx_b| ≤ 1
 ∧ |cz_a - cz_b| ≤ 1
 ∧ |cy_a - cy_b| ≤ 1
```

Используется в:

* генерации (соседние чанки),
* LOD (фронт),
* DTO/HAOS (окрестности активности),
* коллизиях/навигации.

---

## **1.7.6. Дочерние элементы (Children)**

Для иерархических обходов:

```text
region_children(region_route) -> итератор по Block-Route
block_children(block_route)   -> итератор по Chunk-Route
chunk_children(chunk_route)   -> итератор по Octo-Route
octo_children(octo_route)     -> итератор по Voxel-диапазону
```

Требования:

* все дочерние Route наследуют `region` и `octant` родителя;
* индексы уровня-родителя фиксированы,
* индексы дочернего уровня последовательно покрывают полный диапазон
  (см. Topology/1.2, 1.5).

Форма “итератор” намеренно абстрактна — реализация может:

* выдавать ленивую последовательность,
* возвращать массив фиксированного размера,
* использовать генераторы и т.п.

---

## **1.7.7. Итог по Mapping-API**

Mapping-API задаёт **единый слой преобразований** для Route:

* Route ↔ идентификаторы уровней,
* Route ↔ FlatIndex/MortonIndex,
* Route ↔ дискретные мировые координаты (XYZ_int),
* Route ↔ Region + LocalFloat,
* предикаты совпадения/соседства уровней,
* обход дочерних элементов.

Через этот слой:

* генерация, LOD/SVO, DTO/HAOS, ECS и рендер
  работают с одной и той же моделью адресации,
* детали математики (страйды, деление, Morton) остаются в одном месте,
* поведение систем остаётся детерминированным и согласованным
  поверх общей топологии и Routing.

---

# **1.8. Использование Routing в системах движка**

Этот раздел резюмирует, **как Route и Mapping-API** применяются в основных подсистемах движка.

Routing выступает в роли “клеевого слоя” между:

- топологией (см. Topology),
- координатами (см. 1.4),
- оптимизационными слоями (DTO/HAOS),
- LOD/SVO,
- генерацией, ECS и рендером.

---

## **1.8.1. DTO (Dormant Tick Observer)**

DTO использует Route как адресный слой для управления активностью мира.

Основные сценарии:

- **Определение зоны активности**

  - активен ли Region / Block / Chunk;
  - какие уровни должны получать тики сейчас.

- **Расчёт расстояния**

  - расстояние между объектом и зоной:

    ```text
    dist = |route_to_xyz(route_object) - route_to_xyz(route_zone)|
    ```

  - выбор радиуса активности вокруг игрока / камеры.

- **Решение: “проснуться / уснуть”**

  - на основе дистанции и уровня:

    ```text
    if dist < ACTIVE_RADIUS → wake(chunk)
    else → sleep(chunk)
    ```

Route обеспечивает:

- детерминированное сравнение зон (same_chunk / same_region),
- корректное соседство (adjacent_chunks),
- стабильную адресацию при стриминге и переключении областей.

---

## **1.8.2. HAOS (Hybrid Adaptive Optimization System)**

HAOS использует Route как **иерархический адрес нагрузки**.

Основные сценарии:

- **Распределение тиков**

  - выбор, какие Chunk/Octo обновлять в текущем кадре;
  - “волны обновлений” по Morton/Flat-порядку.

- **Структурный обход**

  - проход по:

    ```text
    Region → Block → Chunk → Octo
    ```

  - c учётом приоритетов (дистанция до игрока, важность области).

- **Балансировка**

  - равномерное распределение обновлений по маршрутам,
  - избежание “шипов” нагрузки в отдельных регионах.

Route + Mapping-API дают:

- единый идентификатор области для планировщика,
- предсказуемый порядок обхода (Morton/Flat),
- возможность быстро агрегировать/сворачивать уровни (Up/Down).

---

## **1.8.3. LOD / SVO**

LOD и SVO-структуры рассматривают Route как узел иерархии.

Основные сценарии:

- **Привязка узлов дерева к Route**

  - каждый Chunk/Octo может рассматриваться как SVO-узел;
  - MortonIndex(Route) используется как ключ узла.

- **Навигация по уровням**

  - `Route.Down` → спуск к дочерним узлам (Octo/Voxel),
  - `Route.Up` → подъём к родителям (Chunk/Block/Region).

- **LOD-решения**

  - выбор уровня детализации по расстоянию:

    ```text
    lod_level = f( |route_to_xyz(camera) - route_to_xyz(target)| )
    ```

  - переключение между Route разных уровней (Chunk ↔ Octo ↔ Voxel).

Routing обеспечивает:

- совместимость с Morton-порядком (см. Topology/1.8),
- строгую связь между деревом и топологией,
- детерминированную адресацию узлов для GPU и CPU.

---

## **1.8.4. Генерация**

Генераторы используют Route как **ключ и якорь** для процедурного контента.

Основные сценарии:

- **Привязка сидов к областям**

  ```text
  seed_region = hash( region_id(route) )
  seed_chunk  = hash( region_id(route), chunk_id(route) )
  ```


* **Плитки шума**

  * шум/биом/структура привязывается к Chunk/Block/Region через их ID;
  * воспроизводимость при перезапусках и стриминге.

* **Геометрические структуры**

  * “начало структуры” по Route Block/Chunk:

    ```text
    structure starts at BlockRoute
    ```

Routing даёт:

* стабильную адресацию при бесконечном мире,
* независимость генераторов от физической памяти,
* простой переход Route ↔ VoxelRange для крупных объектов.

---

## **1.8.5. ECS и игровые системы**

В ECS Route выступает как **ключ пространства**.

Основные сценарии:

* **Привязка сущностей к области**

  ```text
  Entity.route = Route
  ```

* **Chunk-entity / Region-entity**

  * отдельные сущности, представляющие Chunk/Block/Region,
  * их ID напрямую основаны на Route.

* **Системы загрузки / выгрузки**

  * принятие решений “создать/удалить чанки” по списку Route,
  * дешёвое сравнение/хранение адресов.

Route в ECS позволяет:

* без коллизий адресовать миллионы/миллиарды элементов,
* прозрачно передавать адрес между LOD, DTO/HAOS, рендером, генерацией,
* использовать Route как часть компонент (например, VoxelComponent, ChunkMeta).

---

## **1.8.6. Рендер и GPU-пайплайн**

Рендер-цепочка опирается на Route для адресации данных.

Основные сценарии:

* **Мешер / генерация геометрии**

  * для воксельных мешей используется:

    ```text
    voxel_coord(route)      // локальный воксель
    morton_voxel(route)     // порядок обхода
    flat_index_voxel(route) // индекс в буфере
    ```

* **Подготовка буферов**

  * Chunk/Octo сортируются по Flat или Morton индексу;
  * используется predictable layout в SSBO/UBO.

* **Окрестности и выборки**

  * поиск соседних чанков/окточанков через:

    ```text
    same_chunk(a, b)
    adjacent_chunks(a, b)
    ```

Routing обеспечивает:

* однозначную привязку CPU- и GPU-данных,
* простое сопоставление “меш ↔ Route ↔ область мира”,
* совместимость с SVO/LOD и DTO/HAOS на уровне одного адресного слоя.

---

## **1.8.7. Итог: Routing как glue-layer**

На этом этапе Routing:

* связывает топологию (Region → Block → Chunk → Octo → Voxel) с:

  * координатами (XYZ_int, LocalFloat),
  * индексами (Flat, Morton),
  * системами DTO/HAOS, LOD/SVO, генерацией, ECS и рендером;
* даёт **канонический Route** как единый формат адреса;
* предоставляет Mapping-API как контракт для всех подсистем;
* гарантирует обратимость и детерминированность преобразований.

Следующий слой архитектуры — **Rotation / Direction / Symmetry** —
строится поверх Routing и Topology и определяет:

* ротации маршрутов и областей,
* симметрии (отражения) в пространстве,
* устойчивое представление направлений для логики и генерации.

---