# Examples — как пользоваться этим файлом

Этот документ собран поверх трёх базовых файлов:

- **Topology.md** — про уровни иерархии и систему координат,
- **Routing.md** — про маршруты (Route) и адресацию,
- **Rotation.md** — про повороты и ориентации.

Здесь не вводим новых правил, а **показываем на примерах**, как всё это работает вместе:

- как Region живёт как “кирпич” мира, а не жёсткая клетка;
- как одна и та же иерархия используется разными системами (LOD, DTO, генерация);
- как Route может быть полным или сокращённым;
- как мы совмещаем float-позицию игрока и курсора с дискретной топологией;
- как Rotation и (в будущем) Symmetry позволяют переиспользовать один и тот же контент в разных ориентациях.

Этот файл дополнение к строгим техдокам:  
если Topology/Route/Rotation — это “сухой контракт”, то здесь — примеры того,  
как мы реально ожидаем его применять в R&D и в живом движке.

---

## 1. Region как «кирпич» мира, а не жёсткая клетка

В базовой топологии Region — это не “одна огромная коробка мира”, а **повторяющийся кирпич**, из которых весь мир складывается как стена:

* по X/Z — кладём регионы вширь (горизонтальная карта),
* по Y (через `ry`) — ставим их колонной по вертикали.

Пример вертикальной колонны регионов над одной точкой по X/Z:

```text
R(0,0,+1)  — верхний слой (горы, атмосфера, “небо”)
R(0,0, 0)  — основной слой ландшафта (поверхность, города)
R(0,0,-1)  — нижний слой (шахты, пещеры, адский уровень)
```

Такое представление удобно для:

* **стриминга и LOD**: можно подгружать/выгружать целые слои по высоте,
* **DTO/активности**: будить/усыплять не весь “столб до центра планеты”, а конкретные регионы,
* **логики мира**: явно разделять “мир поверхности”, “глубокий подземный слой”, “верхний слой”.

Region становится **кирпичом**, который можно легко двигать, включать и выключать — а не монолитом, который всегда целиком должен быть в памяти.

---

### 1.1. Почему Region не куб, а “приплюснут” по высоте

В канонической конфигурации один Region имеет размер:

```text
4096 × 4096 × 1024 vox
```

То есть горизонталь примерно в 4 раза длиннее вертикали. Это сделано осознанно:

* большая часть геймплея идёт **по поверхности** → важно иметь широкий и протяжённый мир по X/Z;
* вертикаль тоже важна, но избыток высоты даёт много пустых слоёв “воздуха/камня” и удорожает:

  * генерацию,
  * SVO/LOD по Y,
  * память и кеш.

Такое соотношение позволяет:

* держать **достаточную** высоту для рельефа, гор и подземелий,
* но при этом не превращать каждый Region в огромный куб “от ядра до космоса”.
* при необходимости — просто добавлять ещё один Region по `ry` (ниже или выше), а не раздувать один до бесконечности.

---

### 1.2. Про “кубический” Region 1×1×1 (отдельный профиль мира)

Теоретически ничто не мешает завести **альтернативный профиль топологии**,
где Region будет почти кубическим (1×1×1 по пропорциям), например:

* для отдельного **океанического мира**,
* для **космоса** или орбитального слоя,
* для спец-режимов симуляции.

Важно:

* это **не меняет канон** текущей архитектуры (8×8×2 Blocks как основной профиль),
* такой “кубический Region” — это не “переключатель посередине игры”,
  а **другая конфигурация мира / другой world-профиль**, который может использовать те же принципы топологии и routing.

То есть:

> базовый мир живёт на профиле `Region = 4096×4096×1024 vox`,
> а специальные режимы (море, космос, эксперименты) могут использовать альтернативные настройки Region
> как **отдельные миры**, не сливая всё в одну кучу и не ломая фундаментальную топологию.

---

да, это место как раз можно чуть “заземлить” на реальные практики.

Вот как я бы переписал блок + добавил сравнение — в том же стиле “мы сделали / мы получили”.

---

### 1.3. Октанты: зачем мы ввели буквы вместо знаков

Внутри топологии мы разделили мир не только по “клеткам”, но и по **направлениям**.
Чтобы не таскать везде наборы вида `(+x, -z, +y)` и не ловить ад с `-0 / +0`,
мы ввели **октанты** — 8 направлений:

* A, B, C, D — верхние (sy = `+`)
* E, F, G, I — нижние (sy = `−`)

Мы сознательно выбрали **буквы**, а не просто флаги, потому что:

* мы получили компактное и читаемое обозначение в логах и инспекторах;
* мы не смешиваем буквы октанта с числовыми индексами контейнеров;
* мы можем кодировать направление в 3 бита (sx, sz, sy), не раздувая структуру;
* мы держим одно и то же обозначение во всех слоях — в доке, в коде и в текстовом Route.

По сути, **октант** стал для нас “компасом направления” для адреса:
индексы остаются неотрицательными, а знак и ориентация зашиты в одну букву.

---

#### Почему это не странная выдумка, а нормальный приём

Идея “разнести величину и направление” сама по себе не уникальна — это нормально для крупных систем:

* В **пространственных индексах** (quadtree/octree, Morton, S2/Geohash-подобные схемы)
  мир кодируют как:

  * “номер ячейки / квадранта / октанта”
  * * дополнительные биты детализации внутри неё.
      У нас буква октанта — это по сути компактный “номер сектора пространства”,
      а все остальные индексы (Region/Block/Chunk/Octo/Voxel) живут уже **внутри** этого сектора.

* В больших **поисковых/аналитических системах** (space-partitioning, vector search)
  часто делают то же самое логически:

  * отдельно кодируют **“какой это сектор/ячейка пространства”**,
  * отдельно — координаты/вектор **внутри** этой ячейки.
    Это облегчает шардирование, кэш и быстрый выбор “соседних” зон.
    Наш октант — это лёгкое “direction bucket”, который позволяет всей системе понимать
    “в какую сторону от центра мира живёт этот адрес”.

* В игровых и сетевых протоколах часто есть паттерн:

  * “позиция в мире” + “маленький enum-ориентация (N/E/S/W и т.п.)”.
    Мы делаем похожее, только в 3D и жёстко привязанное к топологии.

Почему это особенно хорошо для гибрида (воксели + меш + вектор):

* Нам нужен **один и тот же признак направления** для всех подсистем:

  * топология (`Region` / октанты),
  * Routing (строковый формат Route),
  * Rotation (куда повернут blueprint),
  * генерация/LOD (в какую сторону растёт структура),
  * сеть/сохранения (компактный флаг ориентации).
* Если бы знак сидел “по чуть-чуть везде” (`-x` тут, `-z` там, где-то `ry<0`),
  каждая подсистема интерпретировала бы это по-своему.
  Мы же собрали **весь знак в одном месте** — в октанте —
  и дальше спокойно живём с неотрицательными индексами.

То есть:

> буквы октантов — это не декоративный прикол,
> а нормальная инженерная схема: компактный “ключ направления”,
> который можно одинаково читать и человеком, и кодом, и использовать в гибридном движке как общий язык между подсистемами.

---

### 1.4. Иерархия как общий язык для всех систем движка

Мы зафиксировали единую иерархию:

```text
Region → Block → Chunk → Octochunk → Voxel
```

Тем самым мы получили не просто “структуру хранения”, а **общий язык для всех подсистем**:

* генерация спрашивает: “дай все Chunk в этом Block”;
* LOD/SVO смотрит на список видимых Chunk/Octo;
* DTO/HAOS решает, какие Region / Block / Chunk будить или усыплять;
* Routing работает поверх той же цепочки уровней;
* Rotation и блюпринты могут ссылаться на те же контейнеры.

Так мы превращаем эту иерархию в **кровеносную систему движка**:
подсистемы разные, но “кровь и сосуды” у всех общие.

Во многих движках уровни вроде чанков, секторов и зон существуют,
но каждый модуль тянет одеяло на себя, придумывает свои размерности и свои координаты.
Мы же сознательно зафиксировали **одну каноническую иерархию**,
и теперь все системы обязаны говорить на этом языке.

Для гибридного движка (меш + воксель + вектор) это особенно критично:
без общего топологического языка сложная структура быстро превращается в хаос.

---

### 1.5. Две параллельные системы координат: дискретная топология и локальный float

Мы сознательно вывели две параллельные, но связные модели координат:

1. **Дискретная топология**

   * уровни: Region / Block / Chunk / Octochunk / Voxel;
   * все значения — целочисленные индексы ≥ 0;
   * это удобно для хранения, сериализации, SVO/LOD, DTO, Routing.

2. **Локальная float-позиция внутри Region**

   * `local_pos = (x, z, y) ∈ ℝ³`;
   * это основа для физики, навигации, движения, анимации.

Мы получили между ними явный мост:

* для движения и физики мы живём во float (`local_pos`);
* когда нам нужно понять, в какой именно **контейнер** попала точка,
  мы берём `floor(local_pos)` и через страйды раскладываем её по уровням:

```text
Region + LocalFloat
  → (Block, Chunk, Octo, Voxel, Octant)
  → Route
```

И наоборот:

* из Route мы можем восстановить:

  * центр конкретного вокселя,
  * центр чанка,
  * позицию блока в мировом пространстве,
  * и использовать это как опорную точку для float-логики.

Так мы получили **биекцию двух представлений**:

* “мир как непрерывный вектор” — для геймплея и физики,
* “мир как строгая решётка контейнеров” — для памяти, стриминга, индексов и деревьев.

---

### 1.6. Пропуск уровней: одна иерархия — разные глубины для разных задач

Благодаря фиксированной иерархии и мосту float ↔ индексы
мы можем позволить разным системам **останавливаться на своей глубине**:

* SVO / LOD:

  * используют в основном Region + Chunk (и иногда Octo);
  * им не нужно опускаться до отдельных вокселей.

* DTO / HAOS:

  * чаще оперируют Region / Block / Chunk;
  * Octo/Voxel нужны только при более тонкой настройке активности.

* Редакторы и локальные симуляции:

  * работают до уровня Voxel,
  * или в режиме `Region + Voxel`, не перечисляя Block/Chunk явно.

Так мы получили **модульное использование одной иерархии**:
структура всегда одна, но каждый слой движка выбирает свой “уровень детализации” работы.

---

### 1.7. Local float как база для будущих DYN-контейнеров

Когда мы смотрим вперёд, на идею DYN-контейнеров
(динамические объёмы, внутри которых живут сложные фигуры, свои AABB/OBB, локальные SVO и т.д.),
становится видно, что эта двойная модель координат — это не роскошь, а фундамент.

Мы можем:

* снаружи мира говорить о контейнере на языке топологии и роутинга:
  `Region + Chunk + DYN-ID + локальная позиция контейнера`;
* внутри контейнера жить в своей локальной float-сетке,
  со своей детализацией, своей физикой, своим DTO.

Мы уже получили всё необходимое:

* строгую иерархию контейнеров,
* Route как канонический адрес,
* локальный float внутри Region,

и благодаря этому DYN-контейнеры становятся **логическим следующим слоем**,
а не хаотичным костылём поверх непонятной системы координат.

---

## 2. Полный маршрут: когда нам нужна точка “до вокселя”

В топологии мы зафиксировали иерархию:

```text
Region → Block → Chunk → Octochunk → Voxel
```

В Routing мы сделали так, чтобы один объект `Route` мог описывать **путь через все эти уровни**.

Когда нам нужно “максимально точное положение” — мы берём **полный маршрут**.

Пример:

```text
R0− / I / B44 / C7 / O1 / v(3|14|2)
```

Здесь мы:

* выбрали регион `R0−`,
* зафиксировали направление через октант `I`,
* указали Block, Chunk, Octochunk,
* указали локальный воксель `v(3|14|2)` внутри этого Octochunk.

Что мы получаем:

* один `Route` однозначно описывает **конкретный воксель** во всём мире;
* мы можем:

  * преобразовать его в абсолютные координаты XYZ,
  * сериализовать в бинарный или текстовый формат,
  * положить в логи, инспектор, ECS-компонент.

Полный маршрут нужен, когда мы:

* копируем/переносим участки мира,
* разбираем баги “почему именно этот воксель не такой”,
* хотим, чтобы несколько систем (LOD, DTO, генерация) говорили об одной и той же точке без двусмысленности.

---

### 2.1. Сокращённый маршрут: Region + Chunk для LOD и стриминга

Во многих задачах нам не нужна точность “до вокселя”.
Для LOD, стриминга или culling мы чаще думаем чанками.

Мы сделали так, что Route может быть **сокращённым**:
он хранит только нужные уровни, остальные остаются пустыми (None).

Пример:

```text
R0+ / C7
```

Здесь мы:

* работаем в регионе `R0+`,
* указываем только Chunk с ID `7`,
* не прописываем Block/Octo/Voxel явно.

Что мы получаем:

* такой маршрут естественно используется для:

  * загрузки/выгрузки чанков,
  * построения LOD-карт,
  * грубого culling (“виден ли чанк или нет”);
* нам не нужно каждый раз вручную таскать `(rx, rz, ry, cx, cz, cy)` отдельными полями —
  мы говорим: **“вот Route чанка”**, и все системы понимают, о каком уровне идёт речь.

---

### 2.2. Локальный маршрут: Chunk + Voxel в редакторе

Когда мы уже знаем, в каком чанке работаем (например, редактор сцены держит текущий Chunk в контексте),
нам достаточно маршрута внутри этого контейнера.

Мы используем форму:

```text
C7 / v(12|30|4)
```

Здесь мы:

* считаем, что Region и Octant уже известны контексту (камера, сцена),
* указываем:

  * `C7` — текущий чанк,
  * `v(12|30|4)` — локальный воксель внутри этого чанка.

Что мы получаем:

* простой и короткий адрес для инструментов редактирования;
* понятный формат для:

  * кистей,
  * выбора вокселя,
  * локальных симуляций (огонь, вода, разрушение) внутри чанка.

Мы сознательно отделили:

* “глобальный Route” (с Region/Octant),
* и “локальный Route внутри контейнера”,

чтобы редакторы и внутренние системы могли работать проще, не теряя связи с топологией.

---

### 2.3. Соседний чанк: смещение маршрута вместо ручных координат

Для работы с соседями (например, генерация или LOD) к примеру постоянно нужно:

> “найти соседний чанк справа/слева/вперёд/назад”.

Вместо того чтобы вручную дергать индексы и думать про границы,
мы используем Route + смещение.

Пример:

* у нас есть маршрут чанка:

```text
R0+ / C7
```

* хотим получить чанк **справа по X**.

Алгоритмически мы делаем:

1. Превращаем Route в абсолютные координаты XYZ (по формуле из топологии).
2. Добавляем смещение `(+CHUNK_SIZE, 0, 0)`.
3. Нормализуем XYZ обратно в новый Route.

Что получаем:

* операция “соседний чанк” становится **чистой функцией над Route**,
  а не хаотическим набором `cx+1`, `если вышли за границу — меняем блок/регион` и т.п.;
* можем легко реализовать:

  * соседей по X/Z,
  * поиск диагональных чанков,
  * обход областей мира по кольцам/спиралям.

Routing здесь выступает как “адресный протокол”:
мы больше не думаем руками о том, как именно устроены уровни —
мы двигаем маршруты и доверяем топологии нормализацию.

---

### 2.4. Принадлежность: кто кого содержит

В топологии зафиксировали строгую вложенность:

```text
Region → Block → Chunk → Octochunk → Voxel
```

В Routing мы используем эту цепочку как **логику “кто внутри кого живёт”**.

Говорим:

* Block **содержит** набор Chunk’ов,
* Chunk содержит Octochunk’и,
* Octochunk содержит Voxel’и.

Пример — берём:

```text
Route A = R0+ / B12
Route B = R0+ / B12 / C7
```

Интуитивно:

* мы считаем, что `Route A` описывает область (Block),
* `Route B` описывает конкретный Chunk внутри этого блока.

Тогда проверка “принадлежит ли B блоку A” для нас означает:

* совпадают Region и Octant (если Octant учитываем),
* совпадает Block,
* и у B уровень Chunk просто **дописывает** путь дальше.

Что мы получаем:

* простой способ говорить:
  “этот chunk принадлежит этому block’у”
  “этот voxel принадлежит этому chunk’у”;
* удобную основу для DTO/генерации:

  * DTO может хранить активные Block/Chunk и быстро проверять,
    попадает ли конкретный Route внутрь активной зоны;
  * генератор может сказать: “я обрабатываю вот этот Block и всё, что ниже по дереву”.

---

### 2.5. Route и DTO: “мы будим только то, что внутри области”

Мы хотим, чтобы DTO умел грубо решать: **“какие зоны мира сейчас живые?”**

Представим, что:

* храним “область интереса” как Route более крупного уровня, например:

```text
ActiveRegion = R0+
ActiveBlock  = R0+ / B12
```

* и при этом у нас есть отдельные маршруты чанков:

```text
ChunkRoute = R0+ / B12 / C7
```

Тогда DTO может:

* считать `ChunkRoute` активным, если он **принадлежит** `ActiveBlock`,
* усыпить все Route, которые лежат вне активных Block/Region.

Что мы получаем:

* DTO не оперирует “голыми XYZ” или какими-то отдельными индексами,
* он работает на **том же языке, что и топология** — Route,
* любые решения “разбудить / усыпить” основаны на проверке:

  > “Этот Route находится внутри этой адресной области или нет?”

Тем самым мы связываем:

* топологическую иерархию,
* Routing как адресный слой,
* и DTO как наблюдателя активности.

---

### 2.6. Строковый формат Route: мы сделали человекочитаемый “адрес”

Мы договорились, что один и тот же Route должен:

* одинаково читаться человеком,
* без потерь кодироваться/декодироваться в структуру.

Мы ввели канонический вид строки, например:

```text
R0− / I / B44 / C7 / O1 / v(3|14|2)
```

Здесь:

* `R0−` — регион и слой по вертикали;
* `I` — октант (направление);
* `B44` — Block;
* `C7` — Chunk;
* `O1` — Octochunk;
* `v(3|14|2)` — локальный воксель (x|z|y).

Мы получаем:

* формат, который можно копировать в логи, devtools, консоль;
* возможность легко “на глаз” понять, что это за адрес;
* гарантированную обратимость:

  ```text
  decode("R0− / I / B44 / C7 / O1 / v(3|14|2)") == исходный Route
  ```

Для сокращённых случаев:

* Region + Voxel:

  ```text
  R0+ / A / v(300|1800|120)
  ```

* Region + Chunk:

  ```text
  R4− / D / C7
  ```

получаем всё тот же канонический стиль,
просто с меньшим количеством уровней.

---

### 2.7. Route как “общий формат ключа” между системами

Фактически, введя Route, мы сделали одну вещь:

> мы перестали таскать по системам “горсть разных индексов”,
> и дали всем один **общий формат ключа**, который понимают топология, DTO, LOD, генерация, рендер и инструменты.

* ECS может хранить Route в компонентах;
* LOD может сортировать/группировать Route по Chunk/Region;
* DTO может хранить списки активных Route-областей;
* генераторы могут использовать Route как основную “плитку мира”;
* роутинг и ротация (в документе про Rotation) работают над тем же объектом.

То есть Routing в примерах — это всё равно про одно и то же:

> мы взяли строгую иерархию Topology
> и обернули её в единый адресный объект, с которым удобно жить всему движку.

---

### 2.8. Человекочитаемость и уровни подробности

Когда мы вводили Route и строковый формат, мы сознательно сделали его **режимным** и **опциональным**:

* мы можем держать Route **только как структурный объект** в коде;
* а человекочитаемую строку (`R0− / I / B44 / C7 / O1 / v(3|14|2)`) включать только:

  * в логах,
  * в инспекторе,
  * в devtools.

Тем самым мы получили два режима:

1. **Машинный** — системы работают с float-координатами и структурным Route.
2. **Человекочитаемый** — когда нужно посмотреть, где именно что сломалось, мы выводим Route как строку.

При этом мы не обязаны всегда использовать **полный** маршрут.
Для разных задач нам хватает разных уровней:

* Для персонажа в рантайме достаточно:

  ```text
  Region + Octant + локальная float-координата персонажа
  ```

  Топология при необходимости сама сможет восстановить Block/Chunk/Octo/Voxel.

* Для курсора или прицеливания нам достаточно:

  ```text
  Region + локальная float-координата точки, куда смотрит курсор
  ```

  Мы можем:

  * работать во float для хит-тестов и raycast’ов,
  * а уже при попадании — нормализовать результат до Route (например, до уровня Chunk или Voxel).

Таким образом, мы получили:

* **одну иерархию** (Region → Block → Chunk → Octo → Voxel),
* **один адресный формат Route**,
* но при этом можем **гибко выбирать глубину** и **включать человекочитаемый режим только там, где он реально нужен** — в логах, инспекторе, редакторах и отладке.

Закидываю кусок про плотность, в том же “мы”-режиме. Его можно будет воткнуть в examples к топологии отдельным подпунктом.

---

## 3. Плотность вокселей: мы меняем детализацию, не ломая иерархию

В базовой топологии мы жёстко зафиксировали **структуру контейнеров**:

```text
Region → Block → Chunk → Octochunk → Voxel
```

и их количество:

* Region всегда = `8×8×2 Blocks`,
* Block всегда = `8×8×8 Chunks`,
* Chunk всегда = `2×2×2 Octochunks`.

Но при этом мы специально оставили **гибкость в плотности вокселей**:
мы можем менять размер чанка в вокселях, а Octochunk всегда остаётся **1/8 чанка**.

Мы получаем такие варианты профилей (примерно):

* Профиль “грубый мир”:

  ```text
  Chunk  = 16×16×16 vox
  Octo   =  8× 8× 8 vox
  ```

* Профиль “средняя детализация”:

  ```text
  Chunk  = 32×32×32 vox
  Octo   = 16×16×16 vox
  ```

* Профиль “канон, высокая детализация”:

  ```text
  Chunk  = 64×64×64 vox
  Octo   = 32×32×32 vox
  ```

Во всех этих случаях:

* количество Chunk’ов в Block не меняется,
* количество Block’ов в Region не меняется,
* Route и сама иерархия топологии остаются теми же.

Мы меняем **только плотность вокселей внутри контейнеров**,
а не логику адресации и не структуру уровней.

---

#### Алгоритм и страйды: что нам нужно зафиксировать

Чтобы эта гибкость не превратилась в кашу, нам нужно:

1. Явно описать **конфигурацию плотности** (профиль):

   * `CHUNK_SIZE = 16 / 32 / 64`,
   * `OCTO_SIZE  = CHUNK_SIZE / 2`,
   * производные `BLOCK_SIZE`, `REGION_SIZE` в вокселях.

2. Пересчитать и зафиксировать **страйды**:

   ```text
   VOXEL_SIZE      = 1
   OCTO_SIZE       = (настроечно: 8 / 16 / 32)
   CHUNK_SIZE      = (настроечно: 16 / 32 / 64)
   BLOCK_SIZE_XZ   = 8 * CHUNK_SIZE
   BLOCK_SIZE_Y    = 8 * CHUNK_SIZE
   REGION_SIZE_XZ  = 8 * BLOCK_SIZE_XZ
   REGION_SIZE_Y   = 2 * BLOCK_SIZE_Y
   ```

3. Обновить формулы:

   * прямые (Route → XYZ),
   * обратные (XYZ → Route),
   * плоские индексы,
   * Morton-индексы,

   чтобы они опирались **на константы текущего профиля**, а не на “захардкоженные 64/32”.

Так мы получаем:

* единый топологический язык,
* несколько допустимых “плотностей” мира (под PC, мобилки, отдельные режимы),
* и устойчивую базу для LOD/SVO:
  один профиль может использоваться как high-res, другой — как low-res,
  при этом Route и структура уровней остаются совместимыми.

---

## 4. Rotation — как мы крутим мир и контейнеры

### 4.1. Что мы называем “ротацией” в этом движке

Мы сознательно зафиксировали очень простой, но мощный базовый случай:

> **мы вращаем вокруг вертикальной оси Y (yaw, поворот по компасу)**
> на углы: 0°, 90°, 180°, 270°.

То есть:

* мы **не наклоняем** сетку (нет pitch/roll),
* мы сохраняем ось Y как “направление вверх”,
* мы переставляем только X и Z местами/знаками.

Такое решение даёт нам:

* совместимость с топологией (каноника `x | z | y` не ломается);
* простые и обратимые формулы:

  * 90°: `(x, z) → (z, -x)`
  * 180°: `(x, z) → (-x, -z)`
  * 270°: `(x, z) → (-z, x)`
* стабильную работу SVO/LOD, Route и всех индексов.

Мы получили:
**ограниченный, но строгий набор ротаций**, который можно использовать в генерации, блюпринтах, декоре, паттернах, не рискуя разорвать топологическую сетку.

---

### 4.2. Поворот локального контейнера (Chunk / Octochunk / Blueprint)

Базовый сценарий, под который мы делали Rotation — это работа с **локальными контейнерами**:

* Chunk,
* Octochunk,
* локальный blueprint (кусок структуры, сохранённый в локальных координатах).

Мы говорим:

> “у нас есть локальная фигура в контейнере,
> и мы хотим использовать её же, но повернуть на 90° / 180° / 270°”.

Пример:

* у нас есть blueprint “стена с дверью” в координатах Chunk:

```text
local (x, z, y) в диапазоне чанка
```

* мы хотим построить эту стену:

  * один раз как “смотрящую на север”,
  * второй раз — повернутую “на восток”.

Что мы делаем:

1. Храним blueprint в **локальной float/целочисленной сетке контейнера**.
2. При применении выбираем угол вращения (0/90/180/270).
3. Для каждого локального блока/вокселя:

   * применяем формулу поворота для `(x, z)`,
   * сохраняем `y` как есть,
   * уже потом через топологию и Route кладём это на мировую сетку.

Что получили:

* один blueprint можно использовать во множестве ориентаций;
* само вращение живёт **в локальной системе контейнера**,
  а топология мира (Region/Block/Chunk/Octo/Voxel) остаётся в своём каноне;
* мы можем делать библиотеки модулей (комнаты, коридоры, части зданий)
  и крутить их как LEGO, не трогая глобальную сетку.

---

### 4.3. Поворот вокруг вертикальной оси мира (Route + Rotation)

Второй уровень — мы используем Rotation **в связке с Routing**.

Идея такая:

> мы можем взять Route, повернуть “направление” (octant / Dir…)
> и при необходимости пересчитать локальные координаты внутри контейнера.

Пример:

* у нас есть абстрактный путь или шаблон:

```text
Dir6: “идти вперёд”
или
маршрут через воксели “линия коридора”
```

* мы хотим:

  * один раз использовать этот паттерн “на север”,
  * в другом месте — “на восток”,
  * в третьем — “на запад”.

Мы делаем:

1. Храним базовое направление в одном эталоне (например, “вперёд по +Z”).
2. Определяем поворот (90°, 180°, 270° вокруг Y).
3. Применяем Rotation:

   * к направлению (Dir6 / Dir26),
   * к локальным координатам, если это набор вокселей/точек.
4. Уже затем заворачиваем всё это в Route и топологию.

Так мы получили:

* единый “эталонный” паттерн траектории или структуры;
* возможность использовать его в любой ориентации без копирования логики;
* предсказуемое поведение: два поворота складываются, а полный оборот возвращает нас в исходное состояние.

---

### 4.4. Почему мы не крутим Y (и почему это окей)

Сделали выбор:

> на базовом уровне **мы не трогаем ось Y** —
> не наклоняем мир и не крутим контейнеры “на бок”.

Причины:

* вся топология построена вокруг идеи: **Y — это вертикаль, XZ — террейн**;
* Morton, плоские индексы, LOD/SVO — всё завязано на канонике `x | z | y`;
* большинство задач в R&D и генерации решаются поворотами по компасу (yaw),
  а не физическим наклоном сетки.

Что мы получаем:

* простые, быстрые и безопасные формулы;
* всегда однозначный “низ” и “верх” мира;
* отсутствие плавающего хаоса, когда кто-то вдруг решил повернуть чанк на 45° “по диагонали”.

Если в будущем будет реальная необходимость в pitch/roll:

* это уже будет **другой слой** (отдельный документ/модуль),
* и, скорее всего, не над топологией (где сетка строгая),
  а над **локальными DYN-контейнерами**, которые можно рассматривать как физические тела со своей внутренней системой координат.

---

### 4.5. Связка Rotation + Route: мы можем крутить “адресуемые фигуры”

Комбо из трёх доков работает так:

* Topology даёт нам контейнеры и строгую решётку.
* Routing даёт нам Route — адрес на этой решётке.
* Rotation даёт нам способ **крутить фигуры и паттерны в рамках этого адресного пространства**, не ломая систему.

Пример:

* сохранили blueprint “комната” как набор локальных координат в условном контейнере (Chunk/Octo).
* знаем Route, куда её нужно разместить: `R0+ / B12 / C7`.
* выбираем угол (90°/180°/270°).
* мы:

  1. вращаем все локальные точки/блоки внутри контейнера по Rotation;
  2. переносим их на мировую сетку через топологию;
  3. если нужно, фиксируем адреса в виде Route (Region / Block / Chunk / Octo / Voxel).

Что получили:

* универсальную схему “рисования паттернов”:

  * не важно, что внутри: воксели, меши или гибрид,
  * важно, что контейнер и адресная система крутятся по единым правилам;
* возможность переиспользовать контент без линий “копипаста для каждой ориентации”.

---

### 4.6. Намёк на Symmetry / Reflection (mirror X / Z / XZ)

После Rotation у нас логично появляется следующий слой:

> **Symmetry / Reflection** — отражения относительно осей X, Z или сразу XZ.

можем:

* брать тот же самый локальный контейнер,
* вместо поворота делать отражение:

  * mirror X: `(x, z) → (-x, z)`
  * mirror Z: `(x, z) → (x, -z)`
  * mirror XZ: `(x, z) → (-x, -z)`

Что это нам теоретически даёт:

* ещё **4 варианта симметрии поверх 4 базовых поворотов** = до 8 конфигураций из одного шаблона;
* мощный инструмент для генерации:

  * пещеры, биомы, коридоры, города,
  * модульные здания с симметрией/асимметрией,
* всё это поверх уже существующей топологии + Routing + Rotation.

Сейчас это можно держать как **надстройку над Rotation** для генерации и блюпринтов,
а не как часть базового математического ядра — чтобы не перегружать первый проход документацией.

---

## 5. Сквозной пример: игрок, курсор и один общий Route

В этом примере мы связываем воедино три слоя:

* топологию (Region → Block → Chunk → Octochunk → Voxel),
* локальную float-позицию внутри Region,
* маршруты `Route`.

---

#### Игрок: `Region + Octant + local float pos`

Состояние игрока в рантайме мы храним в максимально “живом” виде:

```text
Region    = (rx, rz, ry)        // в каком регионе (кирпиче) он находится
Octant    = A..I                // направление относительно центра мира
local_pos = (fx, fz, fy) ∈ ℝ³   // позиция внутри Region (локальный float)
```

Что это нам даёт:

* `local_pos` используют физика, навигация, анимация — всё, что живёт во float.
* Мы **не обязаны** постоянно таскать за игроком индексы Block/Chunk/Octo/Voxel.
* Когда системе нужно узнать, “в каком он чанке / окточанке / вокселе”,
  мы берём `Region + local_pos`, прогоняем через формулы топологии — и получаем все нужные уровни по запросу.

Игрок, грубо говоря, живёт в представлении:

> **Region + Octant + локальная float-координата**,

а вся дискретная иерархия ниже — это производная, которую топология умеет восстанавливать.

---

#### Курсор / луч: `Region + Octant + локальная float-точка попадания`

Когда игрок двигает мышь, мы считаем луч (raycast) от камеры и получаем точку пересечения с миром:

```text
hit_region = (rx, rz, ry)        // регион, в который попал луч
hit_octant = A..I                // направление относительно центра
hit_local  = (hx, hz, hy) ∈ ℝ³   // точка попадания в локальных координатах Region
```

На этом этапе:

* нас интересует **не воксель**, а именно **точка в мире**, куда “смотрит” курсор;

* `hit_local` используется для:

  * хит-тестов,
  * подсветки,
  * UI / выбора объектов;

* координата всё ещё **float** — мы пока не привязываемся к конкретному вокселю или чанку.

То есть и игрок, и курсор живут в одном стиле:

> **Region + Octant + локальная float-позиция**,

разница только в том, что у игрока это его положение, а у курсора — точка попадания луча.

---

#### Нормализация в Route: от float к Chunk/Voxel и дальше по системе

Когда нам уже нужно **топологическое** представление (изменить воксель, загрузить чанк, подсветить ячейку),
мы нормализуем float-координату до дискретной и упаковываем её в `Route`.

1. Приводим float к целочисленной позиции вокселя внутри Region:

```text
vx_world = floor(hx)
vz_world = floor(hz)
vy_world = floor(hy)
```

2. Разлагаем эту позицию по уровням топологии (см. Topology/страйды):

```text
Region → Block → Chunk → Octochunk → Voxel
```

Получаем индексы:

```text
block = (bx, bz, by)
chunk = (cx, cz, cy)
octo  = (ox, oz, oy)
voxel = (vx, vz, vy)
```

3. Собираем **полный Route** для точки попадания:

```text
Route_hit = {
    region: (rx, rz, ry),
    octant: hit_octant,
    block:  Some(bx, bz, by),
    chunk:  Some(cx, cz, cy),
    octo:   Some(ox, oz, oy),
    voxel:  Some(vx, vz, vy),
}
```

Теперь у нас есть **один канонический адрес**, с которым могут работать все системы:

* генерация — понять, какой чанк/окточанк отвечает за эту зону;
* редактирование — точно изменить этот воксель;
* DTO/HAOS — решить, активен ли соответствующий Chunk/Block/Region;
* LOD/SVO — связать этот Route с нужным узлом дерева.

Если детализация “до вокселя” не нужна, мы просто **обрезаем маршрут** до нужного уровня:

* для LOD/стриминга:

  ```text
  Route_chunk = Region + Octant + Chunk
  ```

* для триггеров/зон интереса:

  ```text
  Route_block = Region + Octant + Block
  ```

---

**Итог сквозного примера**

Мы получили один связный поток:

1. Игрок и курсор живут во float-мире:
   `Region + Octant + локальная float-позиция`.

2. Когда надо “приземлиться” на дискретную сетку,
   мы нормализуем float → индексы контейнеров (Block/Chunk/Octo/Voxel).

3. Эти индексы упаковываем в `Route`, который уже понимают все системы движка
   (Topology, Routing, DTO, LOD, генерация, рендер, инструменты).

То есть:

> **float-координаты → топология → Route**
> — один общий язык, который связывает “живую” физику и строгую адресную модель мира.

## 6. Итог / зачем вообще вся эта триада

Все примеры в этом файле показывают не «единственно верный способ», а **набор опций**, которые становятся возможны, когда у движка появляется общий язык:

- строгая топология (Topology),
- единый адресный формат маршрутов (Routing),
- предсказуемые повороты и ориентации (Rotation).

Эти документы намеренно выглядят строгими и требовательными:  
мы сознательно фиксируем канон, чтобы дальше можно было спокойно наращивать хаос — генерацию, DYN-контейнеры, гибрид меш/воксель, свои эксперименты — **не каждый раз заново придумывая координаты и индексы**.

Важно:

* ни один из приёмов не является жёстким «обязательным правилом»;
* любая система может брать только ту глубину, которая ей нужна (Region, Chunk, Voxel, Route и т.д.);
* сами идеи можно развивать по мере R&D — добавлять профили плотности, новые режимы маршрутов, отдельные слои симметрии и отражений.

Если вы дочитали до сюда и у вас появились мысли, сомнения, идеи или альтернативные подходы —  
**я буду искренне благодарен за любой фидбек и комментарии**: в issues, в обсуждениях или в виде своих R&D-черновиков поверх этой базы.

Эта триада — не готовый догмат, а фундамент для дальнейшей унификации и совместного эксперимента.
